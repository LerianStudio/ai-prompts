# Memory Management Orchestrator

## Goal

To guide an AI assistant through effective memory management workflows that enhance cross-session learning, pattern recognition, and context preservation. This orchestrator manages the 5-prompt memory workflow for optimal knowledge retention and retrieval.

## üîó Enhanced Reasoning Integration

**IMPORTANT**: Memory MCP is the foundation of this workflow, complemented by Sequential Thinking MCP:

### Memory MCP as Primary Tool
- All operations center around memory storage and retrieval
- Build persistent knowledge across sessions
- Create searchable, tagged information architecture

### Sequential Thinking MCP Support
- Use `mcp__sequential-thinking__sequentialthinking` for complex pattern analysis
- Break down memory search strategies systematically
- Develop hypotheses about stored patterns
- Validate insights through structured reasoning
- **Example Usage:**
  ```
  mcp__sequential-thinking__sequentialthinking
    thought="Analyzing memory patterns across projects. I see: [patterns]. Need to understand: 1) Common decisions, 2) Repeated problems, 3) Successful solutions."
    nextThoughtNeeded=true
    thoughtNumber=1
    totalThoughts=4
  ```

## Process Overview

This orchestrator manages a **5-phase memory workflow**:

### Phase 1: Memory Analysis & Intelligence
**Objective**: Analyze stored memory, detect patterns, generate insights
**Tool**: m1-memory-analysis.md

### Phase 2: Memory Retrieval & Context
**Objective**: Search and retrieve relevant information
**Tool**: m2-memory-retrieval.md

### Phase 3: Task Management
**Objective**: Manage tasks with memory integration
**Tool**: m3-task-management.md

### Phase 4: Memory Workflow Integration
**Objective**: Establish memory-aware development workflows
**Tool**: m4-memory-workflow.md

### Phase 5: Memory Maintenance
**Objective**: Optimize and maintain memory system
**Tool**: m5-memory-maintenance.md

## Execution Patterns

### üîç Pattern 1: New Project Initialization

```bash
# 1. Analyze existing patterns
claude 0-memory-related/m1-memory-analysis.md
# Check for similar projects, established patterns

# 2. Retrieve relevant context
claude 0-memory-related/m2-memory-retrieval.md
# Find related decisions, architectures, solutions

# 3. Set up task tracking
claude 0-memory-related/m3-task-management.md
# Initialize memory-backed task management
```

### üîÑ Pattern 2: Continuous Learning Loop

```bash
# 1. Store new learnings
claude 0-memory-related/m4-memory-workflow.md
# Capture decisions, patterns, solutions

# 2. Analyze for patterns
claude 0-memory-related/m1-memory-analysis.md
# Detect emerging patterns, anti-patterns

# 3. Maintain system health
claude 0-memory-related/m5-memory-maintenance.md
# Optimize storage, clean outdated entries
```

### üìä Pattern 3: Cross-Project Intelligence

```bash
# 1. Multi-repository analysis
claude 0-memory-related/m1-memory-analysis.md
# Analyze patterns across projects

# 2. Retrieve best practices
claude 0-memory-related/m2-memory-retrieval.md
# Find successful implementations

# 3. Apply to current context
claude 0-memory-related/m4-memory-workflow.md
# Integrate learnings into current project
```

## Memory Operations by Use Case

### Starting a New Feature
```bash
# Search for similar features
claude 0-memory-related/m2-memory-retrieval.md
# Input: "authentication", "user management", etc.

# Set up feature tracking
claude 0-memory-related/m3-task-management.md
# Create memory-backed task structure
```

### Debugging Complex Issues
```bash
# Search for similar problems
claude 0-memory-related/m2-memory-retrieval.md
# Tags: ["bug-fix", "error-type", "component"]

# Analyze solution patterns
claude 0-memory-related/m1-memory-analysis.md
# Find what worked before
```

### Architecture Decisions
```bash
# Store architecture decision
claude 0-memory-related/m4-memory-workflow.md
# Tag: ["arch-decision", "project-name"]

# Retrieve for future reference
claude 0-memory-related/m2-memory-retrieval.md
# Build on established patterns
```

## Quick Reference Commands

### Essential Memory Operations

```bash
# Store important decision
memory_store_decision 
  decision="Use PostgreSQL for main database"
  rationale="Need ACID compliance and complex queries"
  alternatives="Considered MongoDB but lacks transaction support"
  session_id="project-init"
  repository="github.com/org/project"

# Search for patterns
memory_search "database decisions"
memory_find_similar "PostgreSQL implementation"

# Track tasks
memory_tasks todo_write todos=[...]
memory_tasks todo_read

# Analyze patterns
memory_analyze code_quality
memory_get_patterns
```

### Memory Tagging Strategy

Use consistent tags for better retrieval:
- `["architecture", "decision", "project-name"]`
- `["bug-fix", "component", "error-type"]`
- `["feature", "implementation", "technology"]`
- `["learning", "pattern", "anti-pattern"]`
- `["solution", "workaround", "temporary"]`

## Integration with Other Chains

### With Pre-Development
```bash
# Before creating PRD, search for similar features
claude 0-memory-related/m2-memory-retrieval.md

# After PRD approval, store decisions
claude 0-memory-related/m4-memory-workflow.md

# Track pre-dev tasks
claude 0-memory-related/m3-task-management.md
```

### With Code Review
```bash
# Before review, check for patterns
claude 0-memory-related/m1-memory-analysis.md

# After review, store findings
claude 0-memory-related/m4-memory-workflow.md

# Track review action items
claude 0-memory-related/m3-task-management.md
```

## Memory System Best Practices

### 1. Consistent Tagging
- Use standardized tag taxonomy
- Tag at appropriate granularity
- Include context tags (project, component, type)

### 2. Regular Maintenance
- Run memory health checks weekly
- Clean outdated entries monthly
- Optimize storage quarterly

### 3. Cross-Session Continuity
- Always check memory before starting work
- Store significant decisions immediately
- Link related memories with tags

### 4. Pattern Recognition
- Regularly analyze for patterns
- Document anti-patterns
- Share learnings across projects

## Success Metrics

### Memory Health Indicators
- **Storage Efficiency**: <80% capacity used
- **Retrieval Speed**: <100ms average
- **Tag Coverage**: >90% entries tagged
- **Pattern Detection**: Regular new patterns found

### Knowledge Growth Metrics
- Decisions stored and reused
- Patterns identified and applied
- Cross-project learnings
- Reduced repeated mistakes

## Troubleshooting

### Common Issues

1. **Memory Retrieval Failures**
   - Check tag spelling and consistency
   - Broaden search terms
   - Verify repository context

2. **Storage Capacity**
   - Run maintenance routine
   - Archive old entries
   - Optimize tag usage

3. **Pattern Detection**
   - Ensure sufficient data
   - Check tag relationships
   - Adjust analysis parameters

## Final Guidelines

1. **Think Long-term**: Every decision stored is future knowledge
2. **Tag Thoughtfully**: Good tags enable good retrieval
3. **Analyze Regularly**: Patterns emerge from consistent analysis
4. **Maintain Actively**: A healthy memory system is a useful one
5. **Share Knowledge**: Cross-project insights multiply value

This orchestrator ensures effective use of the Memory MCP system, creating a growing knowledge base that improves development efficiency and decision quality over time.