---
description: 
globs: 
alwaysApply: false
---
# Rule: Generating Tasks from PRD and TRD Analysis

## Goal

To guide an AI assistant in analyzing both Product Requirements Document (PRD) and Technical Requirements Document (TRD) to generate atomic, functional tasks (phases) that serve as the foundation for project implementation. Each task must deliver a complete, working, and testable application increment.

## Process

1. **Read Both Documents:** The AI must first read both the PRD and TRD documents for comprehensive understanding from `/docs/pre-development/`
2. **Verify Chain Validation:** Ensure validation-report-[feature-name].md shows PASS status before proceeding
3. **Analyze Development Roadmap:** Extract and understand the phases outlined in both PRD and TRD
4. **Apply Atomic Principles:** Ensure each task is self-contained and delivers working functionality
5. **Generate Tasks:** Create detailed task specifications using the structure below
6. **Save Output:** Save as `tasks-[feature-name].md` in `/docs/pre-development/tasks/` directory

## Input Documents Analysis

### PRD Analysis Requirements
- **Development Roadmap (Section 13):** Extract the high-level phases and their scope
- **Logical Dependency Chain (Section 14):** Understand the foundation-first approach
- **Functional Requirements (Section 5):** Map requirements to deliverable phases
- **User Stories (Section 3):** Identify user value delivery points
- **Success Metrics (Section 9):** Define measurable outcomes for each task

### TRD Analysis Requirements
- **Implementation Roadmap (Section 16):** Extract technical phases and dependencies
- **Component Design (Section 6):** Understand technical component breakdown
- **Technology Stack (Section 3):** Identify technical deliverables
- **Testing Strategy (Section 12):** Ensure each phase includes testing
- **Deployment Architecture (Section 13):** Define deployment milestones

## Atomic Phase Principles

### Definition of "Atomic"
Each task MUST be:
- **Self-Contained:** Can be developed, tested, and deployed independently
- **Functional:** Delivers working software that users can interact with
- **Testable:** Has clear acceptance criteria and can be validated
- **Deployable:** Results in a runnable application (even if limited scope)
- **Valuable:** Provides measurable user or business value

### Phase Validation Checklist
Before finalizing each task, ensure:
- [ ] **Independent Deployment:** Can be deployed without dependencies on future phases
- [ ] **User Interaction:** Users can perform meaningful actions with this phase alone
- [ ] **Complete Feature Set:** All components needed for the phase are included
- [ ] **Quality Standards:** Testing, monitoring, and observability are included
- [ ] **Rollback Capability:** Can be safely rolled back if issues arise

## Task Structure

Each generated task should include these sections (strictly follow this structure):

### 1. Task Overview
- **Task ID:** MT-[number] (e.g., MT-001, MT-002)
- **Task Name:** Clear, descriptive name (e.g., "CLI Foundation with Local Storage")
- **Phase Type:** Foundation, Core Feature, Enhancement, Integration, Production
- **Duration Estimate:** Rough timeline (e.g., "4-6 weeks")
- **Atomic Validation:** Confirm this delivers a working application

### 2. Deliverable Description
- **Primary Deliverable:** What working software will be delivered
- **User Value:** How users benefit from this phase
- **Business Value:** What business objective this achieves
- **Working Definition:** Exact criteria for "working application"

### 3. Functional Scope
- **Included Features:** Specific features implemented in this phase
- **User Capabilities:** What users can accomplish with this phase
- **API Endpoints:** Which endpoints are functional (if applicable)
- **UI Components:** Which interface elements are working (if applicable)

### 4. Technical Scope
- **Architecture Components:** Which technical components are built
- **Data Model:** What data structures are implemented
- **Integration Points:** Which integrations are functional
- **Infrastructure:** What deployment infrastructure is required
- **Architecture Patterns:** Hexagonal Architecture compliance requirements
- **lib-commons Integration:** Required lib-commons components and patterns
- **lib-auth Integration:** Authentication and authorization patterns (for Midaz projects)

### 5. Dependencies
- **Required Previous Phases:** Which tasks must be completed first
- **External Dependencies:** Third-party services, libraries, or tools needed
- **Internal Dependencies:** Existing system components required
- **Blocking Dependencies:** What could prevent this phase from starting

### 6. Acceptance Criteria
- **Functional Criteria:** Numbered list of functional requirements
- **Technical Criteria:** Numbered list of technical requirements
- **Quality Criteria:** Performance, security, and reliability standards
- **User Acceptance:** How users will validate the deliverable

### 7. Testing Requirements
- **Unit Testing:** Required unit test coverage and scope
- **Integration Testing:** Integration points that must be tested
- **Cross-Task Integration:** How this task integrates with previous completed tasks
- **End-to-End Testing:** Complete user workflows to validate
- **Performance Testing:** Load and performance validation requirements
- **System Integration:** Full system validation with all completed tasks

### 8. Deployment Definition
- **Deployment Target:** Where this phase will be deployed
- **Configuration:** Required environment configuration
- **Data Migration:** Any data migration requirements
- **Rollback Plan:** How to safely revert this deployment

### 9. Success Metrics
- **Technical Metrics:** Performance, uptime, error rates
- **User Metrics:** Usage, adoption, satisfaction indicators
- **Business Metrics:** Revenue, efficiency, cost impact
- **Quality Metrics:** Code coverage, bug rates, security compliance

### 10. Risk Assessment
- **Technical Risks:** Implementation challenges and mitigations
- **Integration Risks:** Potential integration issues
- **Timeline Risks:** Factors that could affect delivery
- **Quality Risks:** Potential quality or performance issues

## Example Task Format

```markdown
## MT-001: CLI Foundation with Local Storage

### 1. Task Overview
- **Task ID:** MT-001
- **Task Name:** CLI Foundation with Local Storage
- **Phase Type:** Foundation
- **Duration Estimate:** 4-6 weeks
- **Atomic Validation:** ✅ Delivers a working CLI that can manage tasks locally

### 2. Deliverable Description
- **Primary Deliverable:** Functional CLI application that manages tasks with local file storage
- **User Value:** Developers can create, list, update, and complete tasks locally
- **Business Value:** Provides immediate task management capability without server dependency
- **Working Definition:** CLI responds to all basic commands and persists data locally

### 3. Functional Scope
- **Included Features:**
  - Task creation (`lmmc add "task description"`)
  - Task listing (`lmmc list`)
  - Task status updates (`lmmc start`, `lmmc done`)
  - Local configuration management
  - Shell completion installation
- **User Capabilities:**
  - Create new tasks with descriptions
  - View all tasks with status filtering
  - Mark tasks as started or completed
  - Configure CLI settings
- **API Endpoints:** N/A (local-only phase)
- **UI Components:** Terminal CLI interface with colored output

[Continue with remaining sections...]
```

## Quality Standards

### Completeness Validation
Each task must include:
- [ ] **Clear Success Definition:** Unambiguous criteria for completion
- [ ] **User Workflow:** Complete user journey from start to finish
- [ ] **Technical Architecture:** All required components identified
- [ ] **Testing Strategy:** Comprehensive testing plan
- [ ] **Deployment Plan:** Clear deployment and validation process

### Atomic Validation
Verify each task:
- [ ] **Standalone Value:** Provides value without future phases
- [ ] **Complete Feature Set:** All components needed are included
- [ ] **Working Software:** Results in functional, testable application
- [ ] **User-Facing:** Users can interact with and benefit from the deliverable
- [ ] **Production-Ready:** Includes monitoring, logging, and observability
- [ ] **Deployable:** Complete deployment process defined

## Task Deployment Workflow

### Git Workflow for Tasks (Atomic Phases):

1. **Task Branch:** Create tasks-implementation branch for each task
   ```bash
   git checkout -b tasks-implementation/T-[task-id]-[short-name]
   # Example: git checkout -b tasks-implementation/T-001-cli-foundation
   ```

2. **Sub-Task Integration:** All sub-task PRs merge into tasks-implementation branch

3. **Task Completion:** When all sub-tasks are complete:
   ```bash
   # Verify working deployment
   make build && make test && make deploy-staging
   
   # Create PR to develop
   git push origin tasks-implementation/T-[task-id]-[short-name]
   # Create PR: tasks-implementation/T-[task-id] → develop
   ```

4. **Task PR Requirements:**
   - Complete working application increment
   - All tests passing
   - Deployment verified
   - Documentation updated
   - Architecture compliance verified
   - Integration testing with previous tasks completed

## Output Structure

### File Organization
```
docs/pre-development/tasks/
├── tasks-[feature-name].md     # This document
├── phase-dependencies.md            # Dependency visualization
└── acceptance-checklist.md          # Validation checklist
```

### Dependencies Visualization
Include a mermaid diagram showing phase dependencies:
```mermaid
graph TD
    A[MT-001: CLI Foundation] --> B[MT-002: AI Integration]
    B --> C[MT-003: Server Integration]
    C --> D[MT-004: Advanced Features]
    D --> E[MT-005: Production Deployment]
```

## Cross-Task Integration Strategy

### Integration Testing Approach

**After Each Task Completion:**
1. **Backward Compatibility:** Ensure new task doesn't break previous tasks
2. **API Compatibility:** Verify interface contracts remain stable
3. **Data Flow Validation:** Test data flow through completed system
4. **Performance Impact:** Measure system performance with new task
5. **User Journey Testing:** Validate complete user workflows

**Integration Test Types:**
- **API Integration:** Test endpoints work together
- **Data Integration:** Verify data consistency across tasks
- **UI Integration:** Ensure seamless user experience
- **Performance Integration:** System-wide performance validation
- **Security Integration:** End-to-end security validation

**Integration Environments:**
- **Integration Environment:** Dedicated environment for cross-task testing
- **Staging Environment:** Production-like environment for final validation
- **Performance Environment:** Dedicated environment for load testing

### Integration Documentation

**Required for Each Task:**
- **Integration Points:** How this task connects to previous tasks
- **Interface Contracts:** APIs, data formats, communication protocols
- **Integration Tests:** Specific tests to validate cross-task functionality
- **Rollback Procedures:** How to safely revert if integration fails
- **Performance Benchmarks:** Expected system performance with this task

## Integration with Development Chain

### Input Sources
- **PRD Section 13:** Development Roadmap phases
- **PRD Section 14:** Logical Dependency Chain
- **TRD Section 16:** Implementation Roadmap
- **User Stories:** Value delivery validation

### Output Usage
- **generate-sub-tasks.mdc:** Uses tasks to create detailed sub-tasks
- **Project Planning:** Provides sprint/milestone boundaries
- **Team Coordination:** Defines handoff points between teams
- **Stakeholder Communication:** Shows delivery milestones
- **Integration Testing:** Provides framework for cross-task integration

## Validation Checklist

Before finalizing tasks:
- [ ] **PRD Alignment:** All PRD phases represented in tasks
- [ ] **TRD Alignment:** Technical roadmap matches task structure
- [ ] **Atomic Principle:** Each task delivers working software
- [ ] **Dependency Logic:** Dependencies are logical and minimal
- [ ] **User Value:** Each phase provides measurable user benefit
- [ ] **Technical Completeness:** All required components included
- [ ] **Testing Coverage:** Comprehensive testing strategy defined
- [ ] **Deployment Readiness:** Clear deployment and validation plan

## Final Instructions

1. **Read Both Documents:** Always analyze both PRD and TRD thoroughly
2. **Apply Atomic Thinking:** Each task must be a complete, working increment
3. **Validate Dependencies:** Ensure dependencies are necessary and minimal
4. **Define Success Clearly:** Each task must have unambiguous completion criteria
5. **Include Quality Measures:** Testing, monitoring, and observability in every phase
6. **Plan for Users:** Each phase should provide tangible user value
7. **Next Step:** After completing tasks, use `@generate-sub-tasks.mdc` for detailed breakdown

## Relationship to Chain

This rule is the third step in the development chain:
1. **create-prd.mdc** → Defines business requirements and high-level phases
2. **create-trd.mdc** → Translates to technical specifications and implementation roadmap
3. **generate-tasks.mdc** → Creates atomic, functional development phases ← **YOU ARE HERE**
4. **generate-sub-tasks.mdc** → Breaks down each task into implementable sub-tasks