---
description: Quick technical implementation strategy within existing architecture
globs: 
alwaysApply: false
---
# Rule: Creating a Technical Approach for Features

## üß† Enhanced Analysis Tools - USE THESE!

**CRITICAL:** Leverage these tools throughout the technical approach creation process:

### üß© Memory MCP Integration
- **Retrieve architecture context:** Use `mcp__lerian-memory__memory_read` with `operation="search"` for existing architecture, tech stack, and implementation patterns
- **Store technical decisions:** Use `mcp__lerian-memory__memory_create` with `operation="store_decision"` for implementation strategy, technology choices, and integration approaches
- **Reference similar implementations:** Use `mcp__lerian-memory__memory_read` with `operation="search"` for comparable technical solutions from past features
- **Link to feature brief:** Use `mcp__lerian-memory__memory_read` with `operation="search"` for feature requirements and constraints from previous phase
- **Session tracking:** Use `mcp__lerian-memory__memory_tasks` with `operation="todo_write"` for technical approach workflow management
- **Tags to use:** `["tech-approach", "implementation", "architecture", "feature-name", "integration"]`

### üîÑ Sequential Thinking MCP
- **Tool:** Use `mcp__sequential-thinking__sequentialthinking` for complex technical analysis
- **Use for:** Architecture integration analysis, technology evaluation, implementation path validation
- **Pattern:** Feature requirements ‚Üí existing architecture ‚Üí integration points ‚Üí implementation strategy
- **Benefit:** Ensures technical approach aligns with existing system and minimizes architectural risk

### üß† Zen MCP Tools (ARCHITECTURAL INSIGHTS)
**Use Zen for technical deep dives:**
- **`mcp__zen__analyze`** - Analyze existing codebase for integration patterns
  ```bash
  mcp__zen__analyze
    files=["src/api/", "src/services/"]
    prompt="How can we integrate [feature] with existing architecture?"
    model="pro"
    analysis_type="architecture"
  ```
- **`mcp__zen__thinkdeep`** - Explore technical trade-offs and alternatives
  ```bash
  mcp__zen__thinkdeep
    prompt="What are the trade-offs between [approach1] vs [approach2] for [feature]?"
    model="pro"
    thinking_mode="high"
    focus_areas=["performance", "maintainability", "scalability"]
  ```
- **`mcp__zen__codereview`** - Validate technical approach against best practices

### üöÄ Task Tool (ARCHITECTURE EXPLORATION)
**Use Task for comprehensive technical search:**
```bash
Task(
  description="Find integration patterns",
  prompt="Search for how existing features integrate with [system components] to identify reusable patterns and avoid architectural conflicts"
)
```

**Pro tip:** Combine all tools for comprehensive technical analysis - Task finds patterns, Zen analyzes trade-offs, Memory stores decisions!

## Goal

To guide an AI assistant in creating a focused Technical Approach that defines implementation strategy within existing architecture, ensuring seamless integration and efficient development.

## Process

1. **Complexity-Based Approach:** Adjust technical depth based on feature complexity
   - **[ADAPT]:** Simple features focus on integration, complex features explore alternatives
   - üß© **Memory Action:** Use `mcp__lerian-memory__memory_read` with `operation="find_similar"` for pattern matching

2. **Read Feature Brief:** Load approved feature brief from previous phase
   - üß© **Memory Action:** Use `mcp__lerian-memory__memory_read` with:
     ```
     operation="search"
     options={
       "query": "feature-brief [feature-name] requirements user-stories complexity",
       "repository": "github.com/[org]/[repo]"
     }
     ```
   - **[OPTIMIZE]:** Extract risk factors and constraints for technical consideration

3. **Retrieve Architecture Context:** Use Memory MCP to understand existing system
   - üß© **Memory Action:** Search for reusable patterns:
     ```
     operation="find_similar"
     options={
       "problem": "implementing [feature-type] with [constraints]",
       "repository": "github.com/[org]/[repo]"
     }
     ```
   - **[FLEX]:** Reference successful past implementations

4. **Analyze Integration Points:** Identify how feature integrates with existing system
   - üîÑ **Sequential Thinking:** Multi-path analysis for complex features:
     ```
     thought="Analyzing integration for [feature]. Evaluating: 1) Reuse existing patterns, 2) Minimal new components, 3) Performance impact"
     nextThoughtNeeded=true
     thoughtNumber=1
     totalThoughts=4
     branchId="integration-analysis"
     ```

5. **Ask Technical Questions:** Scale questions to complexity
   - **Simple (1-2 questions):** Confirm integration approach
   - **Medium (2-4 questions):** Add performance and scalability
   - **Complex (4-6 questions):** Include alternatives and trade-offs
   - **IMPORTANT:** WAIT for user responses before proceeding

6. **Generate Technical Approach:** Create implementation strategy with estimates
   - **[ADAPT]:** Include cost estimates for each approach
   - **[OPTIMIZE]:** Reference similar implementations from Memory
   - üß© **Memory Action:** Store technical decisions with justifications

7. **Request Technical Review:** Present approach with clear trade-offs:
   - "Please review this technical approach. I've included effort estimates and identified [X] reusable patterns from past features."
   - **WAIT for user approval or feedback**
   - üß© **Memory Action:** Use `mcp__lerian-memory__memory_create` with:
     ```
     operation="store_chunk"
     options={
       "content": "User technical feedback: [feedback details]",
       "repository": "github.com/[org]/[repo]",
       "session_id": "[current-session]"
     }
     ```

7. **Incorporate Feedback:** Update approach based on user's technical preferences
   - üß© **Memory Action:** Use `mcp__lerian-memory__memory_create` with:
     ```
     operation="store_decision"
     options={
       "decision": "Technical approach adjustments",
       "rationale": "[changes based on feedback]",
       "repository": "github.com/[org]/[repo]",
       "session_id": "[current-session]"
     }
     ```

8. **Save Technical Approach:** After approval, save as `tech-approach-[feature-name].md` in `/docs/pre-development/`
   - üß© **Memory Action:** Use `mcp__lerian-memory__memory_create` with:
     ```
     operation="create_thread"
     options={
       "name": "Feature Development: [feature-name]",
       "description": "Feature brief through technical approach",
       "chunk_ids": ["[previous-chunk-ids]"],
       "repository": "github.com/[org]/[repo]"
     }
     ```

## User Interaction Guidelines

### Technical Decision Points

Ask **2-4 focused technical questions** maximum. Focus on:

1. **Implementation Strategy:** How should this integrate with existing codebase?
2. **Performance Requirements:** Any specific performance or scale considerations?
3. **Data Strategy:** How should data be stored/accessed?
4. **Integration Approach:** Preferred method for connecting with existing features?

### Example Question Sets

**For Frontend Features:**
- "Should this be a new component or extend existing [component X]?"
- "Any specific UI framework preferences within our current [React/Vue/Angular] setup?"
- "How should this feature handle state management with our existing [Redux/Vuex/etc]?"

**For Backend Features:**
- "Should this be a new service or extend existing [service X]?"
- "Any preferences for data storage within our current [database] setup?"
- "How should this integrate with our existing authentication/authorization?"

**For API Features:**
- "Should this follow our existing REST/GraphQL patterns?"
- "Any specific versioning or backward compatibility requirements?"
- "How should this handle rate limiting and caching?"

## Technical Approach Structure

Create technical approach using this structure:

```markdown
# Technical Approach: [Feature Name]

## üèóÔ∏è Implementation Overview

**Feature:** [Feature name from brief]
**Implementation Type:** [Frontend/Backend/Full-stack/Integration]
**Integration Strategy:** [How this connects with existing system]
**Estimated Complexity:** [Low/Medium/High based on integration points]

### üí∞ Cost Estimates

#### Development Effort
- **Total Estimate:** [X] days ([Y] hours)
- **Breakdown by Phase:**
  - Foundation Setup: [X] hours
  - Core Implementation: [Y] hours
  - Integration & Testing: [Z] hours

#### Approach Options (For Complex Features)
| Approach | Effort | Risk | Benefits |
|----------|--------|------|----------|
| **Option 1: [Name]** | [X] days | Low/Med/High | [Key benefits] |
| **Option 2: [Name]** | [Y] days | Low/Med/High | [Key benefits] |
| **Recommended** | **[Choice]** | **[Risk]** | **[Why this option]** |

### üîÑ Pattern Reuse Opportunities
- **Similar Implementation:** [Reference to past feature]
- **Reusable Components:** [Existing components to leverage]
- **Time Saved:** ~[X] hours through pattern reuse

## üìã Architecture Integration

### Existing Architecture Alignment
- **Current Architecture:** [Brief description of relevant existing architecture]
- **Integration Points:** [Specific components/services this feature connects with]
- **Data Flow:** [How data moves through existing and new components]
- **Dependencies:** [Existing services/components this feature depends on]

### Component Integration Strategy
```mermaid
graph TD
    A[Existing Component 1] -->|Integration Point| B[New Feature Component]
    B -->|Data Flow| C[Existing Component 2]
    B -->|API Calls| D[Existing Service]
```

## üõ†Ô∏è Technical Implementation

### Technology Stack
- **Frontend:** [Specific technologies within existing stack]
- **Backend:** [Specific technologies within existing stack]
- **Database:** [Database approach within existing schema]
- **APIs:** [API design approach within existing patterns]
- **Authentication:** [How feature uses existing auth system]

### File Structure and Code Organization
```
[existing-project-structure]/
‚îú‚îÄ‚îÄ [existing-directories]/
‚îú‚îÄ‚îÄ [new-feature-directory]/
‚îÇ   ‚îú‚îÄ‚îÄ components/          # New UI components
‚îÇ   ‚îú‚îÄ‚îÄ services/           # New business logic
‚îÇ   ‚îú‚îÄ‚îÄ models/             # New data models
‚îÇ   ‚îî‚îÄ‚îÄ tests/              # Feature-specific tests
‚îî‚îÄ‚îÄ [modifications-to-existing-files]
```

### Implementation Approach

#### Phase 1: Foundation Setup
- **Database Changes:** [Schema modifications needed]
- **API Extensions:** [New endpoints or service modifications]
- **Core Models:** [New data structures]

#### Phase 2: Core Implementation
- **Business Logic:** [Core feature functionality]
- **Integration Points:** [Connections with existing features]
- **Data Processing:** [How feature processes and stores data]

#### Phase 3: User Interface
- **UI Components:** [New interface elements]
- **User Experience:** [How users interact with feature]
- **Integration with Existing UI:** [How feature fits in existing interface]

## üîó Integration Specifications

### API Design
```javascript
// New API endpoints following existing patterns
GET    /api/v1/[existing-resource]/[feature-endpoint]
POST   /api/v1/[existing-resource]/[feature-endpoint]
PUT    /api/v1/[existing-resource]/[feature-endpoint]/:id
DELETE /api/v1/[existing-resource]/[feature-endpoint]/:id
```

### Database Integration
```sql
-- New tables following existing naming conventions
CREATE TABLE [existing_prefix]_[feature_table] (
  id UUID PRIMARY KEY,
  [existing_foreign_key] UUID REFERENCES [existing_table](id),
  [feature_specific_fields],
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Modifications to existing tables (if needed)
ALTER TABLE [existing_table] ADD COLUMN [feature_column] [type];
```

### Service Integration
- **[Existing Service 1]:** [How feature integrates/extends this service]
- **[Existing Service 2]:** [How feature consumes this service]
- **New Service Components:** [What new services need to be created]

## üìä Data Strategy

### Data Model Extensions
- **New Entities:** [Data structures specific to this feature]
- **Existing Entity Modifications:** [Changes to existing data models]
- **Relationships:** [How new data relates to existing data]

### Data Migration Strategy
- **Backward Compatibility:** [How to maintain existing data integrity]
- **Migration Scripts:** [Database changes needed]
  - **Go Projects:** Implement migrations as separate service (e.g., `cmd/migrate/main.go`)
  - **Migration Tool:** Use existing migration framework (e.g., golang-migrate, goose)
  - **Version Control:** Track migrations with sequential versioning
- **Data Validation:** [How to ensure data quality during transition]

## üîí Security and Authentication

### Authentication Integration
- **User Permissions:** [What permissions are needed for this feature]
- **Role-Based Access:** [How feature respects existing user roles]
- **API Security:** [Authentication/authorization for new endpoints]

### Security Considerations
- **Data Protection:** [How feature protects sensitive data]
- **Input Validation:** [Validation strategy for user inputs]
- **Error Handling:** [How feature handles and logs security events]

## ‚ö° Performance Considerations

### Performance Requirements
- **Response Time:** [Expected performance targets]
- **Throughput:** [Expected load and concurrent users]
- **Resource Usage:** [Memory, CPU, storage considerations]

### Optimization Strategy
- **Caching:** [What data should be cached and how]
- **Database Optimization:** [Query optimization and indexing]
- **Frontend Performance:** [Loading strategies and optimization]

### Monitoring and Metrics
- **Performance Metrics:** [What to measure]
- **Logging Strategy:** [What events to log]
- **Error Tracking:** [How to monitor feature health]

## üß™ Testing Strategy

### Testing Approach
- **Unit Tests:** [What components need unit testing]
- **Integration Tests:** [How to test integration with existing system]
- **End-to-End Tests:** [User workflow testing strategy]

### Test Data Strategy
- **Test Fixtures:** [Test data needed]
- **Mock Services:** [What external dependencies to mock]
- **Environment Setup:** [Testing environment requirements]

### Quality Assurance
- **Code Review Process:** [How feature code will be reviewed]
- **Testing Checklist:** [Key testing criteria]
- **Performance Testing:** [Load and performance validation]

### Quality Checks Requirements
**CRITICAL:** Each implementation must include language-specific quality validation:

#### Go Projects
```bash
# Run after each implementation task
make fmt              # Code formatting
make vet              # Static analysis
gosec ./...          # Security analysis
govulncheck ./...    # Vulnerability check
perfsprint ./...     # Performance analysis
make lint            # Comprehensive linting
go test ./...        # Test execution

# After quality checks pass, build to ensure compilation
go build ./...       # Build verification
```

#### TypeScript/JavaScript Projects
```bash
# Run after each implementation task
npm run lint         # ESLint code quality
npm run typecheck    # TypeScript validation
npm test            # Test execution
npm run build       # Production build verification
```

#### Python Projects
```bash
# Run after each implementation task
ruff check .         # Linting and formatting
mypy .              # Type checking
pytest              # Test execution
black .             # Code formatting
```

**FAILURE PROTOCOL:** If quality checks fail:
1. Fix issues immediately before proceeding
2. Document quality violations in memory: `memory_store_chunk` with tag `quality-violation`
3. Re-run checks to ensure resolution
4. Only proceed when ALL quality checks pass

## üöÄ Deployment Strategy

### Deployment Approach
- **Deployment Method:** [How feature will be deployed]
- **Feature Flags:** [Progressive rollout strategy]
- **Rollback Plan:** [How to safely revert if needed]

### Environment Strategy
- **Development:** [How feature is developed and tested]
- **Staging:** [Integration testing environment]
- **Production:** [Production deployment considerations]

### Configuration Management
- **Feature Configuration:** [What settings are configurable]
- **Environment Variables:** [Environment-specific configuration using .env files]
  - **Development:** Use `.env` files for local configuration
  - **Production:** Use environment variables for deployment
  - **Template:** Provide `.env.example` with all required variables
  - **Preference:** Avoid YAML/TOML config files when possible
- **Feature Toggles:** [How to enable/disable feature via environment variables]

## üìè Implementation Constraints

### Technical Constraints
- **Existing Architecture Limitations:** [What constraints exist]
- **Technology Compatibility:** [Compatibility requirements]
- **Performance Constraints:** [System limitations to consider]

### Business Constraints
- **Timeline Requirements:** [Development time constraints]
- **Resource Limitations:** [Development resource constraints]
- **Compliance Requirements:** [Regulatory or policy constraints]

## üîÑ Risk Assessment

### Technical Risks
- **Integration Complexity:** [Risk of integration issues]
- **Performance Impact:** [Risk of degrading existing system]
- **Data Migration:** [Risk of data loss or corruption]

### Mitigation Strategies
- **Integration Risk:** [How to minimize integration problems]
- **Performance Risk:** [How to prevent performance degradation]
- **Data Risk:** [How to ensure data safety]

## üìù Implementation Tasks Preview

### High-Level Task Categories
1. **Database Setup:** [Database schema and migration tasks]
2. **Backend Implementation:** [Server-side logic and API tasks]
3. **Frontend Implementation:** [User interface and experience tasks]
4. **Integration Testing:** [System integration validation tasks]
5. **Deployment Preparation:** [Production readiness tasks]

### Dependencies and Sequencing
- **Sequential Dependencies:** [Tasks that must be done in order]
- **Parallel Opportunities:** [Tasks that can be done simultaneously]
- **External Dependencies:** [Tasks waiting on external factors]

## ‚úÖ Definition of Done

### Technical Completion Criteria
- [ ] **Feature integrates seamlessly with existing system**
- [ ] **All new APIs follow existing patterns and conventions**
- [ ] **Database changes are backward compatible**
- [ ] **Feature respects existing authentication and authorization**
- [ ] **Performance meets or exceeds existing system standards**
- [ ] **All integration points are tested and validated**
- [ ] **Documentation is updated for new components**

### Quality Gates
- [ ] **Code follows existing style guides and conventions**
- [ ] **All tests pass including integration tests**
- [ ] **Performance benchmarks meet requirements**
- [ ] **Security review passes**
- [ ] **Feature can be safely deployed and rolled back**

## üîó Next Steps

This technical approach provides the foundation for:
- **Implementation Plan:** Detailed task breakdown with git workflow
- **Development Execution:** Clear implementation guidance
- **Integration Validation:** Testing and quality assurance approach
- **Deployment Planning:** Production readiness and rollout strategy
```

## Memory Actions During Process

### Initial Context Retrieval
```
memory_search "architecture-patterns tech-stack integration-points" repository="[project-repo]"
memory_search "[feature-name] requirements user-stories" repository="[project-repo]"
memory_store_chunk
  content="Starting technical approach for [feature-name]. Architecture context: [context summary]"
  tags=["tech-approach", "started", "feature-name", "architecture"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### After User Technical Input
```
memory_store_chunk
  content="Technical preferences for [feature-name]: [user responses summary]"
  tags=["tech-approach", "user-input", "technical-decisions"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### After Approach Creation
```
memory_store_decision
  decision="Technical implementation strategy for [feature-name]"
  rationale="Integration approach: [approach]. Technology choices: [choices]. Architecture impact: [impact]"
  context="Implementation phases: [count]. Integration points: [list]. Dependencies: [list]"
  session_id="[current-session]"
  repository="[project-repo]"
```

### After User Approval
```
memory_create_thread
  name="Feature Technical Development: [feature-name]"
  description="Feature brief through technical approach with implementation roadmap"
  chunk_ids=["[feature-brief-chunks]", "[tech-approach-chunks]"]
  repository="[project-repo]"
```

## Quality Validation

Before finalizing technical approach, ensure:

### Architecture Consistency
- [ ] **Follows existing architectural patterns**
- [ ] **Uses established technology stack**
- [ ] **Integrates cleanly with existing components**
- [ ] **Respects existing data models and relationships**

### Implementation Feasibility
- [ ] **Approach is technically sound**
- [ ] **Dependencies are available and stable**
- [ ] **Performance requirements are achievable**
- [ ] **Security requirements are addressed**

### Integration Validation
- [ ] **All integration points are identified**
- [ ] **Data flow is clearly defined**
- [ ] **API contracts are consistent**
- [ ] **Authentication/authorization is integrated**

## Final Instructions

1. **Architecture First** - Always align with existing system architecture
2. **Integration Focus** - Prioritize clean integration over new patterns
3. **Performance Aware** - Consider impact on existing system performance
4. **Security Consistent** - Follow established security patterns
5. **Testing Integrated** - Plan testing approach within existing framework
6. **Deployment Ready** - Ensure approach supports safe deployment

This technical approach provides the foundation for efficient implementation planning and development execution within existing system constraints.