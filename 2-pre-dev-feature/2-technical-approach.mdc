---
description: Quick technical implementation strategy within existing architecture
globs: 
alwaysApply: false
---
# Rule: Creating a Technical Approach for Features

## 🧠 Enhanced Analysis Tools - USE THESE!

**CRITICAL:** Leverage these tools throughout the technical approach creation process:

### 🧩 Memory MCP Integration
- **Retrieve architecture context:** `memory_search` for existing architecture, tech stack, and implementation patterns
- **Store technical decisions:** `memory_store_decision` for implementation strategy, technology choices, and integration approaches
- **Reference similar implementations:** `memory_search` for comparable technical solutions from past features
- **Link to feature brief:** `memory_search` for feature requirements and constraints from previous phase
- **Tags to use:** `["tech-approach", "implementation", "architecture", "feature-name", "integration"]`

### 🔄 Sequential Thinking MCP
- **Use for:** Architecture integration analysis, technology evaluation, implementation path validation
- **Pattern:** Feature requirements → existing architecture → integration points → implementation strategy
- **Benefit:** Ensures technical approach aligns with existing system and minimizes architectural risk
- **When:** During architecture analysis and implementation strategy development

**Pro tip:** Always reference existing architecture decisions to ensure consistency and avoid reinventing solutions!

## Goal

To guide an AI assistant in creating a focused Technical Approach that defines implementation strategy within existing architecture, ensuring seamless integration and efficient development.

## Process

1. **Read Feature Brief:** Load approved feature brief from previous phase
   - 🧩 **Memory Action:** `memory_search` to retrieve feature brief decisions and requirements

2. **Retrieve Architecture Context:** Use Memory MCP to understand existing system architecture
   - 🧩 **Memory Action:** `memory_search` for architecture patterns, tech stack, and integration points

3. **Analyze Integration Points:** Identify how feature integrates with existing system
   - 🔄 **Sequential Thinking:** Map feature requirements to existing architecture components

4. **Ask Technical Questions:** Gather specific technical preferences and constraints
   - **IMPORTANT:** WAIT for user responses before proceeding
   - Focus on implementation strategy within existing constraints

5. **Generate Technical Approach:** Create comprehensive implementation strategy
   - 🧩 **Memory Action:** `memory_store_decision` for key technical choices and rationale

6. **Request Technical Review:** Present approach and ask for feedback:
   - "Please review this technical approach. Are there any technical decisions you'd like to adjust?"
   - **WAIT for user approval or feedback**
   - 🧩 **Memory Action:** `memory_store_chunk` with user technical feedback

7. **Incorporate Feedback:** Update approach based on user's technical preferences
   - 🧩 **Memory Action:** `memory_store_decision` documenting technical changes and rationale

8. **Save Technical Approach:** After approval, save as `tech-approach-[feature-name].md` in `/docs/pre-development/`
   - 🧩 **Memory Action:** Link feature brief and technical approach in memory thread

## User Interaction Guidelines

### Technical Decision Points

Ask **2-4 focused technical questions** maximum. Focus on:

1. **Implementation Strategy:** How should this integrate with existing codebase?
2. **Performance Requirements:** Any specific performance or scale considerations?
3. **Data Strategy:** How should data be stored/accessed?
4. **Integration Approach:** Preferred method for connecting with existing features?

### Example Question Sets

**For Frontend Features:**
- "Should this be a new component or extend existing [component X]?"
- "Any specific UI framework preferences within our current [React/Vue/Angular] setup?"
- "How should this feature handle state management with our existing [Redux/Vuex/etc]?"

**For Backend Features:**
- "Should this be a new service or extend existing [service X]?"
- "Any preferences for data storage within our current [database] setup?"
- "How should this integrate with our existing authentication/authorization?"

**For API Features:**
- "Should this follow our existing REST/GraphQL patterns?"
- "Any specific versioning or backward compatibility requirements?"
- "How should this handle rate limiting and caching?"

## Technical Approach Structure

Create technical approach using this structure:

```markdown
# Technical Approach: [Feature Name]

## 🏗️ Implementation Overview

**Feature:** [Feature name from brief]
**Implementation Type:** [Frontend/Backend/Full-stack/Integration]
**Integration Strategy:** [How this connects with existing system]
**Estimated Complexity:** [Low/Medium/High based on integration points]

## 📋 Architecture Integration

### Existing Architecture Alignment
- **Current Architecture:** [Brief description of relevant existing architecture]
- **Integration Points:** [Specific components/services this feature connects with]
- **Data Flow:** [How data moves through existing and new components]
- **Dependencies:** [Existing services/components this feature depends on]

### Component Integration Strategy
```mermaid
graph TD
    A[Existing Component 1] -->|Integration Point| B[New Feature Component]
    B -->|Data Flow| C[Existing Component 2]
    B -->|API Calls| D[Existing Service]
```

## 🛠️ Technical Implementation

### Technology Stack
- **Frontend:** [Specific technologies within existing stack]
- **Backend:** [Specific technologies within existing stack]
- **Database:** [Database approach within existing schema]
- **APIs:** [API design approach within existing patterns]
- **Authentication:** [How feature uses existing auth system]

### File Structure and Code Organization
```
[existing-project-structure]/
├── [existing-directories]/
├── [new-feature-directory]/
│   ├── components/          # New UI components
│   ├── services/           # New business logic
│   ├── models/             # New data models
│   └── tests/              # Feature-specific tests
└── [modifications-to-existing-files]
```

### Implementation Approach

#### Phase 1: Foundation Setup
- **Database Changes:** [Schema modifications needed]
- **API Extensions:** [New endpoints or service modifications]
- **Core Models:** [New data structures]

#### Phase 2: Core Implementation
- **Business Logic:** [Core feature functionality]
- **Integration Points:** [Connections with existing features]
- **Data Processing:** [How feature processes and stores data]

#### Phase 3: User Interface
- **UI Components:** [New interface elements]
- **User Experience:** [How users interact with feature]
- **Integration with Existing UI:** [How feature fits in existing interface]

## 🔗 Integration Specifications

### API Design
```javascript
// New API endpoints following existing patterns
GET    /api/v1/[existing-resource]/[feature-endpoint]
POST   /api/v1/[existing-resource]/[feature-endpoint]
PUT    /api/v1/[existing-resource]/[feature-endpoint]/:id
DELETE /api/v1/[existing-resource]/[feature-endpoint]/:id
```

### Database Integration
```sql
-- New tables following existing naming conventions
CREATE TABLE [existing_prefix]_[feature_table] (
  id UUID PRIMARY KEY,
  [existing_foreign_key] UUID REFERENCES [existing_table](id),
  [feature_specific_fields],
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Modifications to existing tables (if needed)
ALTER TABLE [existing_table] ADD COLUMN [feature_column] [type];
```

### Service Integration
- **[Existing Service 1]:** [How feature integrates/extends this service]
- **[Existing Service 2]:** [How feature consumes this service]
- **New Service Components:** [What new services need to be created]

## 📊 Data Strategy

### Data Model Extensions
- **New Entities:** [Data structures specific to this feature]
- **Existing Entity Modifications:** [Changes to existing data models]
- **Relationships:** [How new data relates to existing data]

### Data Migration Strategy
- **Backward Compatibility:** [How to maintain existing data integrity]
- **Migration Scripts:** [Database changes needed]
- **Data Validation:** [How to ensure data quality during transition]

## 🔒 Security and Authentication

### Authentication Integration
- **User Permissions:** [What permissions are needed for this feature]
- **Role-Based Access:** [How feature respects existing user roles]
- **API Security:** [Authentication/authorization for new endpoints]

### Security Considerations
- **Data Protection:** [How feature protects sensitive data]
- **Input Validation:** [Validation strategy for user inputs]
- **Error Handling:** [How feature handles and logs security events]

## ⚡ Performance Considerations

### Performance Requirements
- **Response Time:** [Expected performance targets]
- **Throughput:** [Expected load and concurrent users]
- **Resource Usage:** [Memory, CPU, storage considerations]

### Optimization Strategy
- **Caching:** [What data should be cached and how]
- **Database Optimization:** [Query optimization and indexing]
- **Frontend Performance:** [Loading strategies and optimization]

### Monitoring and Metrics
- **Performance Metrics:** [What to measure]
- **Logging Strategy:** [What events to log]
- **Error Tracking:** [How to monitor feature health]

## 🧪 Testing Strategy

### Testing Approach
- **Unit Tests:** [What components need unit testing]
- **Integration Tests:** [How to test integration with existing system]
- **End-to-End Tests:** [User workflow testing strategy]

### Test Data Strategy
- **Test Fixtures:** [Test data needed]
- **Mock Services:** [What external dependencies to mock]
- **Environment Setup:** [Testing environment requirements]

### Quality Assurance
- **Code Review Process:** [How feature code will be reviewed]
- **Testing Checklist:** [Key testing criteria]
- **Performance Testing:** [Load and performance validation]

## 🚀 Deployment Strategy

### Deployment Approach
- **Deployment Method:** [How feature will be deployed]
- **Feature Flags:** [Progressive rollout strategy]
- **Rollback Plan:** [How to safely revert if needed]

### Environment Strategy
- **Development:** [How feature is developed and tested]
- **Staging:** [Integration testing environment]
- **Production:** [Production deployment considerations]

### Configuration Management
- **Feature Configuration:** [What settings are configurable]
- **Environment Variables:** [Environment-specific configuration]
- **Feature Toggles:** [How to enable/disable feature]

## 📏 Implementation Constraints

### Technical Constraints
- **Existing Architecture Limitations:** [What constraints exist]
- **Technology Compatibility:** [Compatibility requirements]
- **Performance Constraints:** [System limitations to consider]

### Business Constraints
- **Timeline Requirements:** [Development time constraints]
- **Resource Limitations:** [Development resource constraints]
- **Compliance Requirements:** [Regulatory or policy constraints]

## 🔄 Risk Assessment

### Technical Risks
- **Integration Complexity:** [Risk of integration issues]
- **Performance Impact:** [Risk of degrading existing system]
- **Data Migration:** [Risk of data loss or corruption]

### Mitigation Strategies
- **Integration Risk:** [How to minimize integration problems]
- **Performance Risk:** [How to prevent performance degradation]
- **Data Risk:** [How to ensure data safety]

## 📝 Implementation Tasks Preview

### High-Level Task Categories
1. **Database Setup:** [Database schema and migration tasks]
2. **Backend Implementation:** [Server-side logic and API tasks]
3. **Frontend Implementation:** [User interface and experience tasks]
4. **Integration Testing:** [System integration validation tasks]
5. **Deployment Preparation:** [Production readiness tasks]

### Dependencies and Sequencing
- **Sequential Dependencies:** [Tasks that must be done in order]
- **Parallel Opportunities:** [Tasks that can be done simultaneously]
- **External Dependencies:** [Tasks waiting on external factors]

## ✅ Definition of Done

### Technical Completion Criteria
- [ ] **Feature integrates seamlessly with existing system**
- [ ] **All new APIs follow existing patterns and conventions**
- [ ] **Database changes are backward compatible**
- [ ] **Feature respects existing authentication and authorization**
- [ ] **Performance meets or exceeds existing system standards**
- [ ] **All integration points are tested and validated**
- [ ] **Documentation is updated for new components**

### Quality Gates
- [ ] **Code follows existing style guides and conventions**
- [ ] **All tests pass including integration tests**
- [ ] **Performance benchmarks meet requirements**
- [ ] **Security review passes**
- [ ] **Feature can be safely deployed and rolled back**

## 🔗 Next Steps

This technical approach provides the foundation for:
- **Implementation Plan:** Detailed task breakdown with git workflow
- **Development Execution:** Clear implementation guidance
- **Integration Validation:** Testing and quality assurance approach
- **Deployment Planning:** Production readiness and rollout strategy
```

## Memory Actions During Process

### Initial Context Retrieval
```
memory_search "architecture-patterns tech-stack integration-points" repository="[project-repo]"
memory_search "[feature-name] requirements user-stories" repository="[project-repo]"
memory_store_chunk
  content="Starting technical approach for [feature-name]. Architecture context: [context summary]"
  tags=["tech-approach", "started", "feature-name", "architecture"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### After User Technical Input
```
memory_store_chunk
  content="Technical preferences for [feature-name]: [user responses summary]"
  tags=["tech-approach", "user-input", "technical-decisions"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### After Approach Creation
```
memory_store_decision
  decision="Technical implementation strategy for [feature-name]"
  rationale="Integration approach: [approach]. Technology choices: [choices]. Architecture impact: [impact]"
  context="Implementation phases: [count]. Integration points: [list]. Dependencies: [list]"
  session_id="[current-session]"
  repository="[project-repo]"
```

### After User Approval
```
memory_create_thread
  name="Feature Technical Development: [feature-name]"
  description="Feature brief through technical approach with implementation roadmap"
  chunk_ids=["[feature-brief-chunks]", "[tech-approach-chunks]"]
  repository="[project-repo]"
```

## Quality Validation

Before finalizing technical approach, ensure:

### Architecture Consistency
- [ ] **Follows existing architectural patterns**
- [ ] **Uses established technology stack**
- [ ] **Integrates cleanly with existing components**
- [ ] **Respects existing data models and relationships**

### Implementation Feasibility
- [ ] **Approach is technically sound**
- [ ] **Dependencies are available and stable**
- [ ] **Performance requirements are achievable**
- [ ] **Security requirements are addressed**

### Integration Validation
- [ ] **All integration points are identified**
- [ ] **Data flow is clearly defined**
- [ ] **API contracts are consistent**
- [ ] **Authentication/authorization is integrated**

## Final Instructions

1. **Architecture First** - Always align with existing system architecture
2. **Integration Focus** - Prioritize clean integration over new patterns
3. **Performance Aware** - Consider impact on existing system performance
4. **Security Consistent** - Follow established security patterns
5. **Testing Integrated** - Plan testing approach within existing framework
6. **Deployment Ready** - Ensure approach supports safe deployment

This technical approach provides the foundation for efficient implementation planning and development execution within existing system constraints.