---
description: Quick feature requirements capture with user stories and acceptance criteria
globs: 
alwaysApply: false
---
# Rule: Creating a Feature Brief

## üß† Enhanced Analysis Tools - USE THESE!

**CRITICAL:** Leverage these tools throughout the feature brief creation process:

### üß© Memory MCP Integration
- **Retrieve product context:** `memory_search` for existing product architecture, features, and user patterns
- **Store feature insights:** `memory_store_chunk` for user requirements, feature rationale, and design decisions
- **Reference similar features:** `memory_search` for comparable features from this or other projects
- **Session tracking:** `memory_tasks` for feature brief workflow management
- **Tags to use:** `["feature-brief", "requirements", "user-stories", "feature-name"]`

### üîÑ Sequential Thinking MCP
- **Use for:** Feature scope analysis, user journey mapping, acceptance criteria validation
- **Pattern:** User need ‚Üí feature value ‚Üí implementation scope ‚Üí acceptance criteria
- **Benefit:** Ensures feature aligns with user needs and business value
- **When:** During requirement analysis and acceptance criteria definition

**Pro tip:** Reference existing product features to ensure consistency and avoid conflicts!

## Goal

To guide an AI assistant in creating a focused Feature Brief that captures requirements, user stories, and acceptance criteria quickly while ensuring integration with existing product architecture.

## Process

1. **Retrieve Product Context:** Use Memory MCP to understand existing product and architecture
2. **Receive Feature Request:** The user provides initial feature description
3. **Ask Focused Questions:** Gather specific details about user needs and business value
   - **IMPORTANT:** WAIT for user responses before proceeding
   - Focus on integration points and user value
4. **Generate Feature Brief:** Create comprehensive feature specification
5. **Request User Review:** Present brief and ask for feedback:
   - "Please review this feature brief. What would you like to change or clarify?"
   - **WAIT for user approval or feedback**
6. **Incorporate Feedback:** Update brief based on user input
7. **Save Feature Brief:** After approval, save as `feature-brief-[feature-name].md` in `/docs/pre-development/`

## üß† Enhanced Process Steps

### Step 1: Retrieve Product Context
```
memory_search "product architecture features user-patterns"
memory_search "existing-features integration-points"
memory_get_context repository="[project-repo]"
```

### Step 2-3: Feature Analysis with Sequential Thinking
Use Sequential Thinking for complex feature analysis:
```
mcp__sequential-thinking__sequentialthinking
  thought="Analyzing feature request: [feature-description]. Need to understand user value, integration points, and scope boundaries."
  thought_number=1
  total_thoughts=3-5
  next_thought_needed=true
```

## User Interaction Guidelines

### Focused Clarifying Questions

Ask **3-5 targeted questions** maximum. Focus on:

1. **User Value:** Who benefits and how?
2. **Integration:** How does this connect with existing features?
3. **Scope:** What's included/excluded in this feature?
4. **Success:** How will we know it's working?
5. **Priority:** How urgent is this feature?

### Example Question Sets

**For New UI Features:**
- "Who is the primary user of this feature and what problem does it solve?"
- "How should this integrate with [existing feature X] that users currently use?"
- "What are the 2-3 most critical actions users need to perform?"
- "How will users discover and access this feature?"

**For API/Backend Features:**
- "What existing systems or features will consume this API?"
- "What data does this feature need access to?"
- "What are the performance/scale requirements?"
- "How should this handle errors and edge cases?"

**For Integration Features:**
- "What external system are we integrating with?"
- "What data flows in/out of our system?"
- "What happens if the external system is unavailable?"
- "How do we handle authentication/authorization?"

## Feature Brief Structure

Create feature brief using this structure:

```markdown
# Feature Brief: [Feature Name]

## üéØ Feature Overview

**Feature Name:** [Clear, descriptive name]
**Requested By:** [User/stakeholder]
**Business Priority:** [High/Medium/Low]
**Estimated Effort:** [Quick assessment: Small/Medium/Large]

## üìã User Stories

### Primary User Stories
- **As a** [user type] **I want** [capability] **so that** [benefit/value]
- **As a** [user type] **I want** [capability] **so that** [benefit/value]
- **As a** [user type] **I want** [capability] **so that** [benefit/value]

### Edge Case Stories
- **As a** [user type] **I want** [edge case handling] **so that** [reliability/usability]

## ‚úÖ Acceptance Criteria

### Functional Requirements
1. **[Core Function 1]**
   - Given: [context/precondition]
   - When: [user action]
   - Then: [expected result]

2. **[Core Function 2]**
   - Given: [context/precondition]  
   - When: [user action]
   - Then: [expected result]

3. **[Integration Point]**
   - Given: [existing system state]
   - When: [feature interaction]
   - Then: [system behavior]

### Non-Functional Requirements
- **Performance:** [response time, throughput requirements]
- **Usability:** [user experience requirements]
- **Security:** [authentication, authorization, data protection]
- **Compatibility:** [browser, device, API version requirements]

## üîó Integration Points

### Existing Features Affected
- **[Feature/System 1]:** [How they interact]
- **[Feature/System 2]:** [How they interact]
- **[Database/API]:** [Data dependencies]

### External Dependencies
- **[Service/API]:** [What we need from them]
- **[Library/Tool]:** [Why we need it]

## üìê Scope Definition

### In Scope (This Feature)
- ‚úÖ [Specific functionality 1]
- ‚úÖ [Specific functionality 2] 
- ‚úÖ [Specific functionality 3]

### Out of Scope (Future Features)
- ‚ùå [Related but separate functionality 1]
- ‚ùå [Related but separate functionality 2]
- ‚ùå [Nice-to-have that can wait]

### Assumptions
- üìã [Technical assumption 1]
- üìã [Business assumption 1]
- üìã [User assumption 1]

## üìä Success Metrics

### User Metrics
- **Adoption:** [How many users will use this?]
- **Usage:** [How often will it be used?]
- **Satisfaction:** [How will we measure user satisfaction?]

### Technical Metrics
- **Performance:** [Response time, error rate targets]
- **Reliability:** [Uptime, failure rate targets]
- **Integration:** [Compatibility, data accuracy targets]

## üé® User Experience Notes

### User Flow
1. [Step 1: How user starts using the feature]
2. [Step 2: Core interaction]
3. [Step 3: Completion/result]

### UI/UX Considerations
- **Interface:** [How feature appears to users]
- **Navigation:** [How users find and access feature]
- **Feedback:** [How system communicates status/results]
- **Error Handling:** [How errors are presented to users]

## üöÄ Business Value

### Problem Solved
[Clear description of user/business problem this feature addresses]

### Value Proposition
- **User Value:** [Direct benefit to users]
- **Business Value:** [Impact on business metrics]
- **Competitive Value:** [Market positioning benefit]

### ROI Justification
- **Cost:** [Development effort estimate]
- **Benefit:** [Expected return/improvement]
- **Risk:** [What happens if we don't build this]

## üîÑ Feature Dependencies

### Prerequisites
- **[Existing Feature/System]:** [Must be in place first]
- **[Data/API]:** [Must be available]

### Enables Future Features
- **[Future Feature 1]:** [How this enables it]
- **[Future Feature 2]:** [How this enables it]

## üìù Additional Notes

### Technical Constraints
- [Any technical limitations or requirements]

### Business Constraints  
- [Timeline, budget, or policy constraints]

### Open Questions
- [Questions that need resolution during technical approach phase]
```

## Memory Actions During Process

### Initial Context Retrieval
```
memory_search "product-architecture existing-features user-patterns" repository="[project-repo]"
memory_store_chunk
  content="Starting feature brief for [feature-name]. Context: [retrieved context summary]"
  tags=["feature-brief", "started", "feature-name"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### After User Clarification
```
memory_store_chunk
  content="User clarification for [feature-name]: [user responses summary]"
  tags=["feature-brief", "user-input", "requirements"]
  session_id="[current-session]"  
  repository="[project-repo]"
```

### After Brief Creation
```
memory_store_decision
  decision="Feature scope and requirements for [feature-name]"
  rationale="Based on user needs: [key user requirements]. Integration with: [existing features]"
  context="User stories: [count]. Acceptance criteria: [count]. Integration points: [list]"
  session_id="[current-session]"
  repository="[project-repo]"
```

### After User Approval
```
memory_create_thread
  name="Feature Development: [feature-name]"
  description="Complete feature development from brief through implementation"
  chunk_ids=["[all-relevant-chunk-ids]"]
  repository="[project-repo]"
```

## Quality Validation

Before finalizing feature brief, ensure:

### Completeness Check
- [ ] **User value clearly defined**
- [ ] **Integration points identified**
- [ ] **Acceptance criteria are testable**
- [ ] **Scope boundaries are clear**
- [ ] **Success metrics defined**

### Consistency Check
- [ ] **Aligns with existing product direction**
- [ ] **Compatible with current architecture**
- [ ] **Follows established user experience patterns**
- [ ] **Considers existing feature interactions**

### Feasibility Check
- [ ] **Scope is reasonable for a single feature**
- [ ] **Dependencies are available or achievable**
- [ ] **No major architectural changes required**
- [ ] **Can be implemented with existing tech stack**

## Integration with Technical Approach

The feature brief provides foundation for:
- **Technical implementation strategy**
- **Architecture integration points**
- **API design requirements**
- **Database schema considerations**
- **Testing strategy planning**

## Final Instructions

1. **Context First** - Always retrieve existing product context before starting
2. **User Focus** - Prioritize user value over technical complexity
3. **Integration Aware** - Consider how feature fits with existing system
4. **Scope Control** - Keep features focused and atomic
5. **Quality Gates** - Validate completeness and consistency
6. **Memory Integration** - Store all decisions and rationale for future reference

This feature brief becomes the foundation for rapid technical approach development and implementation planning.