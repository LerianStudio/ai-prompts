---
description: Quick feature requirements capture with user stories and acceptance criteria
globs: 
alwaysApply: false
---
# Rule: Creating a Feature Brief

## üß† Enhanced Analysis Tools - USE THESE!

**CRITICAL:** Leverage these tools throughout the feature brief creation process:

### üß© Memory MCP Integration
- **Retrieve product context:** Use `mcp__lerian-memory__memory_read` with `operation="search"` for existing product architecture, features, and user patterns
- **Store feature insights:** Use `mcp__lerian-memory__memory_create` with `operation="store_chunk"` for user requirements, feature rationale, and design decisions
- **Reference similar features:** Use `mcp__lerian-memory__memory_read` with `operation="search"` for comparable features from this or other projects
- **Session tracking:** Use `mcp__lerian-memory__memory_tasks` with `operation="todo_write"` for feature brief workflow management
- **Tags to use:** `["feature-brief", "requirements", "user-stories", "feature-name"]`

### üîÑ Sequential Thinking MCP
- **Use for:** Feature scope analysis, user journey mapping, acceptance criteria validation
- **Pattern:** User need ‚Üí feature value ‚Üí implementation scope ‚Üí acceptance criteria
- **Benefit:** Ensures feature aligns with user needs and business value
- **When:** During requirement analysis and acceptance criteria definition

### üß† Zen MCP Tools (LEVERAGE FOR DEPTH)
**Use Zen for enhanced feature analysis:**
- **`mcp__zen__thinkdeep`** - Explore feature implications and edge cases
  ```bash
  mcp__zen__thinkdeep
    prompt="Analyze user needs and implications for [feature]"
    model="pro"
    thinking_mode="high"
  ```
- **`mcp__zen__chat`** - Brainstorm user stories and acceptance criteria
- **Benefits**: Uncover hidden requirements, validate assumptions, identify risks early

### üöÄ Task Tool (EFFICIENT PATTERN SEARCH)
**Use Task for parallel exploration:**
```bash
Task(
  description="Find similar features",
  prompt="Search for existing features that handle [similar functionality] to understand patterns and user expectations"
)
```
**Benefits**: Find reusable patterns, understand user expectations, avoid reinventing solutions

**Pro tip:** Combine Memory MCP + Zen MCP + Task tool for comprehensive feature understanding!

## Goal

To guide an AI assistant in creating a focused Feature Brief that captures requirements, user stories, and acceptance criteria quickly while ensuring integration with existing product architecture.

## Process

1. **Complexity Assessment:** Evaluate feature scope to guide depth of analysis
   - üß© **Memory Action:** `memory_search` for similar features to establish complexity baseline
   - üîÑ **Sequential Thinking:** Multi-factor complexity analysis
   - **[ADAPT]:** Scale question depth based on complexity score

2. **Retrieve Product Context:** Use Memory MCP to understand existing product and architecture
   - üß© **Memory Action:** `memory_search` for existing product architecture and related features
   - üß© **Memory Action:** `memory_read` with `operation="find_similar"` for pattern matching
   - üß© **Memory Action:** `memory_tasks` to track feature brief workflow with session_id

3. **Receive Feature Request:** The user provides initial feature description
   - üß© **Memory Action:** `memory_store_chunk` with initial feature request and context
   - **[OPTIMIZE]:** Search for reusable patterns from past implementations

4. **Ask Focused Questions:** Gather specific details scaled to complexity
   - **IMPORTANT:** WAIT for user responses before proceeding
   - **Simple (1-3 questions):** Core functionality and integration point
   - **Medium (3-5 questions):** Add performance and edge cases
   - **Complex (5-7 questions):** Include risk assessment and alternatives
   - üß© **Memory Action:** `memory_search` for similar features and integration patterns

5. **Generate Feature Brief:** Create specification with complexity-appropriate depth
   - **[FLEX]:** Include risk assessment section for complex features
   - **[ADAPT]:** Add pattern references for similar past features

6. **Request User Review:** Present brief and ask for feedback:
   - "Please review this feature brief. What would you like to change or clarify?"
   - **WAIT for user approval or feedback**

7. **Incorporate Feedback:** Update brief based on user input
   - üß© **Memory Action:** `memory_store_decision` with final requirements and rationale

8. **Save Feature Brief:** After approval, save as `feature-brief-[feature-name].md` in `/docs/pre-development/`

## üß† Enhanced Process Steps

### Step 1: Retrieve Product Context
```
memory_search "product architecture features user-patterns"
memory_search "existing-features integration-points"
memory_get_context repository="[project-repo]"
```

### Step 2-3: Feature Analysis with Multiple Tools
**Parallel Analysis Approach:**
```bash
# 1. Use Task for comprehensive search
Task(
  description="Feature pattern search",
  prompt="Find all implementations of [feature-type] including user flows, edge cases, and common pitfalls"
)

# 2. Use Sequential Thinking for structured analysis
mcp__sequential-thinking__sequentialthinking
  thought="Analyzing feature request: [feature-description]. Need to understand user value, integration points, and scope boundaries."
  thought_number=1
  total_thoughts=3-5
  next_thought_needed=true

# 3. Use Zen for deep insights (complex features)
mcp__zen__thinkdeep
  prompt="What are the non-obvious implications and edge cases for [feature]?"
  model="pro"
  thinking_mode="high"
  focus_areas=["user_experience", "system_integration", "scalability"]
```

## User Interaction Guidelines

### Focused Clarifying Questions

Ask **3-5 targeted questions** maximum. Focus on:

1. **User Value:** Who benefits and how?
2. **Integration:** How does this connect with existing features?
3. **Scope:** What's included/excluded in this feature?
4. **Success:** How will we know it's working?
5. **Priority:** How urgent is this feature?

### Example Question Sets

**For New UI Features:**
- "Who is the primary user of this feature and what problem does it solve?"
- "How should this integrate with [existing feature X] that users currently use?"
- "What are the 2-3 most critical actions users need to perform?"
- "How will users discover and access this feature?"

**For API/Backend Features:**
- "What existing systems or features will consume this API?"
- "What data does this feature need access to?"
- "What are the performance/scale requirements?"
- "How should this handle errors and edge cases?"

**For Integration Features:**
- "What external system are we integrating with?"
- "What data flows in/out of our system?"
- "What happens if the external system is unavailable?"
- "How do we handle authentication/authorization?"

## Feature Brief Structure

Create feature brief using this structure:

```markdown
# Feature Brief: [Feature Name]

## üéØ Feature Overview

**Feature Name:** [Clear, descriptive name]
**Requested By:** [User/stakeholder]
**Business Priority:** [High/Medium/Low]
**Estimated Effort:** [Quick assessment: Small/Medium/Large]

## üìã User Stories

### Primary User Stories
- **As a** [user type] **I want** [capability] **so that** [benefit/value]
- **As a** [user type] **I want** [capability] **so that** [benefit/value]
- **As a** [user type] **I want** [capability] **so that** [benefit/value]

### Edge Case Stories
- **As a** [user type] **I want** [edge case handling] **so that** [reliability/usability]

## ‚úÖ Acceptance Criteria

### Functional Requirements
1. **[Core Function 1]**
   - Given: [context/precondition]
   - When: [user action]
   - Then: [expected result]

2. **[Core Function 2]**
   - Given: [context/precondition]  
   - When: [user action]
   - Then: [expected result]

3. **[Integration Point]**
   - Given: [existing system state]
   - When: [feature interaction]
   - Then: [system behavior]

### Non-Functional Requirements
- **Performance:** [response time, throughput requirements]
- **Usability:** [user experience requirements]
- **Security:** [authentication, authorization, data protection]
- **Compatibility:** [browser, device, API version requirements]

## üîó Integration Points

### Existing Features Affected
- **[Feature/System 1]:** [How they interact]
- **[Feature/System 2]:** [How they interact]
- **[Database/API]:** [Data dependencies]

### External Dependencies
- **[Service/API]:** [What we need from them]
- **[Library/Tool]:** [Why we need it]

## üìê Scope Definition

### In Scope (This Feature)
- ‚úÖ [Specific functionality 1]
- ‚úÖ [Specific functionality 2] 
- ‚úÖ [Specific functionality 3]

### Out of Scope (Future Features)
- ‚ùå [Related but separate functionality 1]
- ‚ùå [Related but separate functionality 2]
- ‚ùå [Nice-to-have that can wait]

### Assumptions
- üìã [Technical assumption 1]
- üìã [Business assumption 1]
- üìã [User assumption 1]

## üìä Success Metrics

### User Metrics
- **Adoption:** [How many users will use this?]
- **Usage:** [How often will it be used?]
- **Satisfaction:** [How will we measure user satisfaction?]

### Technical Metrics
- **Performance:** [Response time, error rate targets]
- **Reliability:** [Uptime, failure rate targets]
- **Integration:** [Compatibility, data accuracy targets]

## üé® User Experience Notes

### User Flow
1. [Step 1: How user starts using the feature]
2. [Step 2: Core interaction]
3. [Step 3: Completion/result]

### UI/UX Considerations
- **Interface:** [How feature appears to users]
- **Navigation:** [How users find and access feature]
- **Feedback:** [How system communicates status/results]
- **Error Handling:** [How errors are presented to users]

## üöÄ Business Value

### Problem Solved
[Clear description of user/business problem this feature addresses]

### Value Proposition
- **User Value:** [Direct benefit to users]
- **Business Value:** [Impact on business metrics]
- **Competitive Value:** [Market positioning benefit]

### ROI Justification
- **Cost:** [Development effort estimate]
- **Benefit:** [Expected return/improvement]
- **Risk:** [What happens if we don't build this]

## üîÑ Feature Dependencies

### Prerequisites
- **[Existing Feature/System]:** [Must be in place first]
- **[Data/API]:** [Must be available]

### Enables Future Features
- **[Future Feature 1]:** [How this enables it]
- **[Future Feature 2]:** [How this enables it]

## ‚ö†Ô∏è Risk Assessment (For Complex Features)

### Technical Risks
- **[Risk 1]:** [Description] | **Likelihood:** High/Medium/Low | **Impact:** High/Medium/Low
  - **Mitigation:** [Strategy to address]
- **[Risk 2]:** [Description] | **Likelihood:** High/Medium/Low | **Impact:** High/Medium/Low
  - **Mitigation:** [Strategy to address]

### Integration Risks
- **[System Compatibility]:** [Potential conflicts with existing systems]
- **[Data Migration]:** [Risks related to data changes]
- **[Performance Impact]:** [Potential degradation risks]

### Business Risks
- **[User Adoption]:** [Risk of low adoption and mitigation]
- **[Market Timing]:** [Risk of delayed delivery]
- **[Competitive Response]:** [Risk of competitor advantage]

## üîÑ Pattern References (From Memory MCP)

### Similar Features Implemented
- **[Feature Name]:** [How it was implemented] | **Lessons Learned:** [Key insights]
- **[Feature Name]:** [Reusable patterns] | **Pitfalls Avoided:** [What to watch for]

### Recommended Patterns
- **[Pattern Type]:** [Description and applicability]
- **[Architecture Pattern]:** [How to apply to this feature]

## üìù Additional Notes

### Technical Constraints
- [Any technical limitations or requirements]

### Business Constraints  
- [Timeline, budget, or policy constraints]

### Open Questions
- [Questions that need resolution during technical approach phase]
```

## Memory Actions During Process

### Initial Context Retrieval
```
memory_search "product-architecture existing-features user-patterns" repository="[project-repo]"
memory_store_chunk
  content="Starting feature brief for [feature-name]. Context: [retrieved context summary]"
  tags=["feature-brief", "started", "feature-name"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### After User Clarification
```
memory_store_chunk
  content="User clarification for [feature-name]: [user responses summary]"
  tags=["feature-brief", "user-input", "requirements"]
  session_id="[current-session]"  
  repository="[project-repo]"
```

### After Brief Creation
```
memory_store_decision
  decision="Feature scope and requirements for [feature-name]"
  rationale="Based on user needs: [key user requirements]. Integration with: [existing features]"
  context="User stories: [count]. Acceptance criteria: [count]. Integration points: [list]"
  session_id="[current-session]"
  repository="[project-repo]"
```

### After User Approval
```
memory_create_thread
  name="Feature Development: [feature-name]"
  description="Complete feature development from brief through implementation"
  chunk_ids=["[all-relevant-chunk-ids]"]
  repository="[project-repo]"
```

## Quality Validation

Before finalizing feature brief, ensure:

### Completeness Check
- [ ] **User value clearly defined**
- [ ] **Integration points identified**
- [ ] **Acceptance criteria are testable**
- [ ] **Scope boundaries are clear**
- [ ] **Success metrics defined**

### Consistency Check
- [ ] **Aligns with existing product direction**
- [ ] **Compatible with current architecture**
- [ ] **Follows established user experience patterns**
- [ ] **Considers existing feature interactions**

### Feasibility Check
- [ ] **Scope is reasonable for a single feature**
- [ ] **Dependencies are available or achievable**
- [ ] **No major architectural changes required**
- [ ] **Can be implemented with existing tech stack**

## Integration with Technical Approach

The feature brief provides foundation for:
- **Technical implementation strategy**
- **Architecture integration points**
- **API design requirements**
- **Database schema considerations**
- **Testing strategy planning**

## Final Instructions

1. **Context First** - Always retrieve existing product context before starting
2. **User Focus** - Prioritize user value over technical complexity
3. **Integration Aware** - Consider how feature fits with existing system
4. **Scope Control** - Keep features focused and atomic
5. **Quality Gates** - Validate completeness and consistency
6. **Memory Integration** - Store all decisions and rationale for future reference

This feature brief becomes the foundation for rapid technical approach development and implementation planning.