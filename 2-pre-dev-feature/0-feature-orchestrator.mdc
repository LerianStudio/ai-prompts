---
description: Streamlined orchestrator for quick feature development workflow
globs: 
alwaysApply: false
---
# Rule: Feature Development Workflow Orchestration

## Goal

To guide an AI assistant through a streamlined feature development process that transforms feature requests into implementable tasks quickly. This orchestrator manages a **4-phase feature workflow** optimized for speed while maintaining quality and integration with existing systems.

## üß† Enhanced Reasoning Integration

**IMPORTANT**: Use both Memory MCP and Sequential Thinking MCP for enhanced analysis:

### Memory MCP Integration
- Retrieve existing product context using `mcp__lerian-memory__memory_read` with `operation="search"`
- Reference established tech stack using `mcp__lerian-memory__memory_read` with `operation="get_context"`
- Store feature decisions using `mcp__lerian-memory__memory_create` with `operation="store_decision"`
- Tag entries appropriately using feature-specific tags like `["feature", "feature-name", "architecture"]`

### Sequential Thinking MCP Usage
- Use `mcp__sequential-thinking__sequentialthinking` for feature complexity analysis
- Break down feature requirements into technical components systematically
- Validate feature integration with existing architecture
- Question assumptions and explore implementation alternatives

### üß† Zen MCP Integration (HIGHLY RECOMMENDED)
**Use Zen tools for enhanced analysis and collaboration:**
- **`mcp__zen__thinkdeep`** - For complex architectural decisions and exploring alternatives
- **`mcp__zen__analyze`** - For codebase analysis and pattern identification
- **`mcp__zen__chat`** - For collaborative brainstorming and validation
- **Benefits**: Deeper insights, alternative perspectives, and validation of approaches

### üöÄ Task Tool Usage (POWERFUL FOR SEARCH)
**Use the Task tool for efficient exploration:**
- **When to use**: Searching for patterns, finding similar implementations, exploring codebase
- **Example**: `Task(description="Find auth patterns", prompt="Search for authentication implementations across the codebase")`
- **Benefits**: Parallel search, comprehensive results, reduced context usage

## Process Overview

This orchestrator manages an **adaptive feature workflow** that adjusts based on complexity:

### üîç Phase 0: Complexity Assessment (NEW)
**Objective**: Evaluate feature complexity to determine optimal workflow
**Agent Action**: Analyze feature scope and propose workflow adaptation
**Output**: Complexity score and recommended workflow structure

### Adaptive Workflow Paths:

#### üü¢ Simple Features (1-2 days)
- **Phase 1**: Feature Brief & Technical Approach (merged)
- **Phase 2**: Implementation Plan with integrated testing
- **[FLEX]**: Agent can propose further consolidation

#### üü° Medium Features (3-5 days) 
- **Phase 1**: Feature Brief
- **Phase 2**: Technical Approach
- **Phase 3**: Implementation Plan
- **Phase 4**: Test Strategy
- **[ADAPT]**: Standard 4-phase with flexibility points

#### üî¥ Complex Features (5+ days)
- **Phase 1**: Feature Brief with risk assessment
- **Phase 2**: Architecture Review (additional)
- **Phase 3**: Technical Approach with alternatives
- **Phase 4**: Implementation Plan with milestones
- **Phase 5**: Comprehensive Test Strategy
- **[OPTIMIZE]**: Enhanced pattern matching from past projects

### Core Phases (Adaptive):

### Phase 1: Feature Brief
**Objective**: Capture requirements with complexity-aware depth
**User Interaction**: Required - clarifying questions scaled to complexity
**Output**: `docs/pre-development/feature-brief-[feature-name].md`

### Phase 2: Technical Approach  
**Objective**: Define implementation strategy with pattern reuse
**User Interaction**: Required for medium/complex, optional for simple
**Output**: `docs/pre-development/tech-approach-[feature-name].md`

### Phase 3: Implementation Plan
**Objective**: Define deliverables and decompose into work units
**User Interaction**: Optional - review deliverable structure
**Output**: `docs/pre-development/tasks/feature-[feature-name]/`

### Phase 4: Test Strategy
**Objective**: Define test coverage linked to acceptance criteria
**User Interaction**: Required for complex, optional for simple/medium
**Output**: `docs/pre-development/features/test-plan-[feature-name].md`

## Execution Phases

### üîç Phase 0: Complexity Assessment (NEW)

**Automated complexity evaluation with workflow adaptation:**

```bash
# Initial feature analysis
# AI performs automatic complexity assessment using:
# - Sequential Thinking MCP for multi-factor analysis
# - Memory MCP for similar feature patterns
# - Complexity scoring based on multiple factors

# Process flow:
# 1. AI analyzes initial feature description
# 2. AI searches Memory for similar past features
# 3. AI evaluates complexity factors:
#    - Integration points count
#    - Data model changes required
#    - External dependencies
#    - Security considerations
#    - Performance implications
# 4. AI proposes workflow adaptation
# 5. User reviews and approves workflow structure
```

**Complexity Factors Evaluated:**
- **Scope**: Number of user stories and acceptance criteria
- **Integration**: Count of existing systems affected
- **Architecture**: Need for new patterns or components
- **Risk**: Security, performance, or reliability concerns
- **Dependencies**: External services or major refactoring

**üß† Enhanced with Zen MCP:**
```bash
# Use Zen for deeper complexity analysis
mcp__zen__thinkdeep
  prompt="Analyze feature complexity for [feature]: [description]"
  focus_areas=["integration_complexity", "architectural_impact", "risk_assessment"]
  model="pro"
  thinking_mode="high"
```

**[FLEX] Agent Discretion:**
- Propose phase consolidation for simple features
- Suggest additional phases for complex features
- Recommend pattern reuse from Memory MCP
- Use Task tool for comprehensive pattern search

### üìã Phase 1: Feature Brief

**Interactive process with mandatory user feedback:**

```bash
# Start feature brief creation
claude 2-pre-dev-feature/1-feature-brief.mdc

# Process flow:
# 1. AI retrieves existing product context from Memory MCP
# 2. AI asks focused clarifying questions (WAIT FOR USER RESPONSE)
# 3. User provides feature details
# 4. AI generates feature brief draft
# 5. User reviews and provides feedback (WAIT FOR APPROVAL)
# 6. AI incorporates feedback and finalizes brief
```

**Key User Interactions:**
- Feature description and user value
- Answers to clarifying questions about:
  - User stories and acceptance criteria
  - Integration points with existing features
  - Business priority and constraints
  - Success metrics
- Review and approval of feature brief

**Output**: `docs/pre-development/feature-brief-[feature-name].md`

### üîß Phase 2: Technical Approach

**Build upon approved feature brief with implementation strategy:**

```bash
# Create technical approach based on feature brief
claude 2-pre-dev-feature/2-technical-approach.mdc

# Process flow:
# 1. AI reads approved feature brief
# 2. AI retrieves existing architecture from Memory MCP
# 3. AI asks technical clarifying questions (WAIT FOR USER RESPONSE)
# 4. User provides technical preferences
# 5. AI generates technical approach draft
# 6. User reviews technical strategy (WAIT FOR APPROVAL)
# 7. AI finalizes technical approach
```

**Key User Interactions:**
- Implementation approach within existing architecture
- Integration strategy with current codebase
- Performance and scalability considerations
- Testing approach and deployment strategy
- Review and approval of technical approach

**Output**: `docs/pre-development/tech-approach-[feature-name].md`

### üìù Phase 3: Implementation Plan

**Create atomic, implementable tasks with git workflow:**

```bash
# Generate implementation tasks from feature brief and technical approach
claude 2-pre-dev-feature/3-implementation-plan.mdc

# Process flow:
# 1. AI reads both feature brief and technical approach
# 2. AI analyzes implementation roadmap
# 3. AI generates atomic task breakdown with git workflow
# 4. User optionally reviews task structure (WAIT FOR FEEDBACK if requested)
# 5. User can adjust task organization
# 6. AI incorporates feedback and finalizes implementation plan
```

**Key User Interactions (Optional):**
- Review of proposed implementation phases
- Feedback on task prioritization and scope
- Adjustment of task boundaries
- Approval of implementation structure

**Output**: `docs/pre-development/tasks/feature-[feature-name]/`

### üß™ Phase 4: Test Strategy

**Create focused test strategy for the feature:**

```bash
# Generate test strategy based on feature requirements
claude 2-pre-dev-feature/4-test-strategy.mdc

# Process flow:
# 1. AI analyzes feature brief, technical approach, and tasks
# 2. AI identifies feature-specific testing needs
# 3. AI proposes targeted test coverage (WAIT FOR USER INPUT)
# 4. User provides test priorities and constraints
# 5. AI generates focused test strategy
# 6. User reviews and approves test approach (WAIT FOR APPROVAL)
# 7. AI finalizes test plan with scenarios
```

**Key User Interactions:**
- Feature-specific test coverage targets
- Integration testing priorities
- Performance impact thresholds
- Security considerations
- Review and approval of test strategy

**Output**: `docs/pre-development/features/test-plan-[feature-name].md`

## Key Differences from Product Workflow

### **Assumptions Made**
- ‚úÖ Product architecture is established
- ‚úÖ Tech stack and patterns are defined
- ‚úÖ Development workflow is in place
- ‚úÖ Testing strategy exists
- ‚úÖ Deployment pipeline is functional

### **Focus Areas**
- üéØ **Integration** over architecture decisions
- üéØ **Implementation** over design exploration  
- üéØ **Speed** over comprehensive documentation
- üéØ **Iteration** over upfront planning

### **Reduced Complexity**
- **No PRD**: Feature brief replaces full product requirements
- **No TRD**: Technical approach focuses on implementation strategy
- **No Validation**: Assumes existing architecture validation
- **Faster Feedback**: 4 phases vs 6 phases

## Quick Execution Commands

### Full Feature Workflow
```bash
# Phase 1: Feature Brief with user feedback
claude 2-pre-dev-feature/1-feature-brief.mdc
# [User provides feature details, answers questions, reviews brief]

# Phase 2: Technical Approach with implementation decisions  
claude 2-pre-dev-feature/2-technical-approach.mdc
# [User provides technical preferences, reviews approach]

# Phase 3: Implementation Plan with task breakdown
claude 2-pre-dev-feature/3-implementation-plan.mdc
# [User optionally reviews task breakdown]

# Phase 4: Test Strategy for the feature
claude 2-pre-dev-feature/4-test-strategy.mdc
# [User provides test priorities and approves strategy]
```

### Express Workflow (Minimal user interaction)
```bash
# Create feature brief and technical approach only
claude 2-pre-dev-feature/1-feature-brief.mdc
# [User interaction required]
claude 2-pre-dev-feature/2-technical-approach.mdc
# [User interaction required]
# Skip implementation plan for immediate development
```

## Output Organization

All feature development outputs are systematically organized:

```
docs/pre-development/
‚îú‚îÄ‚îÄ feature-brief-[feature-name].md       # Feature requirements and user stories
‚îú‚îÄ‚îÄ tech-approach-[feature-name].md       # Implementation strategy
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îî‚îÄ‚îÄ test-plan-[feature-name].md      # Feature-specific test strategy
‚îî‚îÄ‚îÄ tasks/
    ‚îî‚îÄ‚îÄ feature-[feature-name]/           # Implementation tasks
        ‚îú‚îÄ‚îÄ overview.md                   # Feature implementation overview
        ‚îî‚îÄ‚îÄ FT-[XX]-[task-name].md        # Individual feature tasks
```

## Memory Integration

Store feature decisions and patterns with appropriate tags:
- `["feature", "brief", "requirements", "feature-name"]` for feature specifications
- `["feature", "technical", "implementation", "feature-name"]` for technical choices
- `["feature", "tasks", "breakdown", "feature-name"]` for task organization
- `["feature", "integration", "existing-system"]` for integration patterns
- `["feature", "testing", "strategy", "feature-name"]` for test approach

## Success Criteria

### Phase Completion Criteria
- **Phase 1**: Feature brief approved with clear requirements and acceptance criteria
- **Phase 2**: Technical approach approved with implementation strategy defined
- **Phase 3**: Implementation plan generated with atomic tasks and git workflow
- **Phase 4**: Test strategy approved with focused coverage targets

### Overall Success Metrics
- Features integrated smoothly with existing system
- Implementation tasks are truly atomic and implementable
- User feedback incorporated at each stage
- Clear path from feature request to implementation
- Minimal disruption to existing architecture

## Best Practices

### For Effective Feature Development

1. **Leverage Existing Context** - Use Memory MCP to retrieve relevant patterns and decisions
2. **Focus on Integration** - Ensure new features work seamlessly with existing functionality
3. **Maintain Consistency** - Follow established patterns and conventions
4. **Quick Validation** - Get user feedback early and often
5. **Atomic Tasks** - Ensure each task can be completed independently
6. **Git-First** - Include git workflow from the start

### üß† When to Use Each Tool

#### Use Task Tool When:
- **Searching for patterns** across the codebase
- **Finding similar implementations** to learn from
- **Exploring multiple aspects** in parallel
- **Reducing context usage** in large searches

#### Use Zen MCP When:
- **Analyzing complex decisions** (use `thinkdeep` with pro model)
- **Reviewing code architecture** (use `analyze` for patterns)
- **Validating approaches** (use `codereview` for quality)
- **Brainstorming alternatives** (use `chat` for ideas)

#### Use Memory MCP When:
- **Starting any phase** to retrieve context
- **Making decisions** to store rationale
- **Completing work** to capture learnings
- **Finding similar work** for pattern reuse

#### Combine All Three When:
- **Complex features** need deep analysis
- **Uncertain approaches** require validation
- **Pattern reuse** can accelerate development
- **Risk assessment** needs multiple perspectives

### For Quality Assurance

1. **Reference Architecture** - Ensure feature aligns with existing system design
2. **Consistent Patterns** - Use established coding patterns and conventions
3. **Testing Strategy** - Include testing approach in technical approach
4. **Performance Consideration** - Evaluate impact on existing system performance
5. **Documentation Updates** - Plan for necessary documentation changes

## Integration with Product Workflow

### When to Use Feature vs Product Workflow

**Use 2-pre-dev-feature for:**
- Adding new functionality to existing products
- Enhancing existing features
- Bug fixes that require significant changes
- Performance improvements
- Integration with new third-party services

**Use 1-pre-dev-product for:**
- New products or applications
- Major architectural changes
- Complete system redesigns
- New technology stack adoption
- Complex multi-feature initiatives

### Workflow Transition

```bash
# Start with product workflow for new systems
claude 1-pre-dev-product/0-pre-dev-orchestrator.mdc

# Switch to feature workflow for enhancements
claude 2-pre-dev-feature/0-feature-orchestrator.mdc
```

## Integration with Code Review Chain

```bash
# After feature implementation begins
# 1. Complete feature development planning (this workflow)
# 2. Implement features based on tasks
# 3. Run code review chain to validate implementation
claude 2-code-review/00-code-review-orchestrator.mdc
```

## Final Instructions

1. **Start Fast** - Feature workflow is designed for speed
2. **Leverage Context** - Use Memory MCP to retrieve existing decisions
3. **Focus on Integration** - Ensure seamless integration with existing system
4. **Iterate Quickly** - Get user feedback and adjust rapidly
5. **Maintain Quality** - Don't sacrifice quality for speed
6. **Document Decisions** - Store important decisions for future features

This orchestrator ensures rapid feature development with continuous user engagement, resulting in well-integrated features that align with existing system architecture and user needs.