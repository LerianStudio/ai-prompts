---
description: Generate Technical Requirements Document focusing on HOW and WHERE
globs: 
alwaysApply: false
---
# Rule: Creating a Technical Requirements Document (TRD)

## Goal

To translate business requirements into technical architecture and design decisions. The TRD answers HOW we'll build the solution and WHERE components will live, without specifying exact implementation details.

## üß† Enhanced Analysis Tools

### Memory MCP Integration
```yaml
Operations:
  - Search: Find architectural patterns, design decisions
  - Store: Save technical choices, trade-offs, constraints
  - Retrieve: Get proven architectures, integration patterns
  
Tags: ["trd", "architecture", "design", "technical", "feature-name"]
```

### Sequential Thinking MCP
```yaml
Use For:
  - Decomposing features into components
  - Analyzing technical trade-offs
  - Identifying integration challenges
  - Mapping data flows

Pattern: Requirements ‚Üí Components ‚Üí Interfaces ‚Üí Data ‚Üí Security
```

### Zen MCP Tools
- **thinkdeep**: Architectural decisions and trade-offs
- **analyze**: System design and complexity analysis
- **planner**: Component breakdown and dependencies

## Process: Architecture-First Design

### Phase 1: Technical Analysis
```yaml
Inputs Required:
  - Approved PRD (Gate 1 passed)
  - Business constraints
  - Non-functional requirements

Parallel Actions:
  1. Pattern Search:
     - Similar architectures
     - Proven patterns
     - Anti-patterns to avoid
  
  2. Component Design:
     - Identify bounded contexts
     - Define service boundaries
     - Plan data ownership
  
  3. Quality Attributes:
     - Performance needs
     - Security requirements
     - Scalability targets
```

### Phase 2: Architecture Definition
Based on PRD requirements, design:
- System architecture
- Component interfaces
- Data models
- Integration patterns

## TRD Structure (Technical-Focused)

### 1. Technical Overview
- Solution architecture summary
- Key design decisions
- Technical constraints addressed

### 2. System Architecture
```yaml
Architecture Style: [e.g., Microservices, Modular Monolith, Serverless]
Pattern: [e.g., Hexagonal, Layered, Event-Driven]

High-Level Components:
  - Component A: Purpose and responsibility
  - Component B: Purpose and responsibility
  - Component C: Purpose and responsibility

Communication Patterns:
  - Synchronous: REST/GraphQL/gRPC
  - Asynchronous: Events/Messages/Queues
```

### 3. Component Design
```markdown
**Component: [Name]**
- **Purpose**: What it does
- **Responsibilities**: 
  - Business logic it owns
  - Data it manages
  - Services it provides
- **Interfaces**:
  - Inbound: How others interact with it
  - Outbound: What it depends on
- **Quality Attributes**:
  - Performance: Targets and constraints
  - Security: Requirements and measures
  - Scalability: Growth considerations
```

### 4. Data Architecture
```yaml
Data Stores:
  - Store 1:
      Type: [Relational/Document/Key-Value]
      Purpose: What data and why
      Ownership: Which component owns it
  
Data Models:
  - Entity 1:
      Attributes: Key fields (no implementation)
      Relationships: How it connects
      Constraints: Business rules

Data Flow:
  - Flow 1: Source ‚Üí Transform ‚Üí Destination
  - Flow 2: Event ‚Üí Process ‚Üí Store
```

### 5. API Design
```markdown
**API: [Name]**
- **Purpose**: What capability it exposes
- **Style**: REST/GraphQL/gRPC/WebSocket
- **Authentication**: How clients authenticate
- **Key Operations**:
  - Operation 1: Purpose and contract
  - Operation 2: Purpose and contract
- **Rate Limiting**: Targets and strategy
- **Versioning**: Approach and compatibility
```

### 6. Security Architecture
```yaml
Security Layers:
  - Network: Boundaries and controls
  - Application: Authentication/Authorization
  - Data: Encryption at rest/transit

Threat Model:
  - Threat 1: Description and mitigation
  - Threat 2: Description and mitigation

Compliance Requirements:
  - Requirement 1: How addressed
  - Requirement 2: How addressed
```

### 7. Integration Architecture
```markdown
**External Systems**:
- System A: 
  - Purpose: Why we integrate
  - Pattern: How we integrate
  - Data Exchange: What we share

**Internal Integrations**:
- Between Component A & B:
  - Protocol: Communication method
  - Contract: Interface agreement
  - Error Handling: Failure scenarios
```

### 8. Performance & Scalability
```yaml
Performance Targets:
  - Response Time: p50, p95, p99
  - Throughput: Requests/second
  - Concurrency: Simultaneous users

Scalability Strategy:
  - Horizontal: Which components scale out
  - Vertical: Which components scale up
  - Data Partitioning: Sharding strategy
```

### 9. Operational Considerations
```markdown
**Monitoring**:
- Key metrics to track
- Alert thresholds
- Dashboard requirements

**Deployment**:
- Deployment topology
- Environment requirements
- Configuration management

**Disaster Recovery**:
- RTO/RPO targets
- Backup strategy
- Failover approach
```

### 10. Technical Risks
```yaml
Risk: [Description]
  Impact: Technical consequence
  Mitigation: Architectural approach
  Monitoring: How we'll detect
```

## What NOT to Include in TRD

‚ùå **Implementation Details**:
- Specific packages/libraries
- Code examples
- Framework versions
- Language specifics

‚ùå **Infrastructure Specifics**:
- Cloud provider details
- Specific services (e.g., AWS RDS)
- Container orchestration
- CI/CD pipelines

‚ùå **Business Logic**:
- PRD requirements (reference only)
- User stories
- Business rules details

## Architecture Decision Records (ADRs)

For each major decision:
```markdown
**ADR-001: [Decision Title]**
- **Context**: Why this decision is needed
- **Options Considered**:
  - Option A: Description, pros, cons
  - Option B: Description, pros, cons
- **Decision**: What we chose and why
- **Consequences**: What this means for the system
```

## Gate 2: Technical Feasibility

Before proceeding to Dependency Map:

```yaml
Gate 2 Checklist:
  Architecture Completeness:
    - [ ] All PRD features mapped to components
    - [ ] Component boundaries are clear
    - [ ] Interfaces are well-defined
  
  Data Design:
    - [ ] Data ownership is clear
    - [ ] Models support requirements
    - [ ] Consistency approach defined
  
  Quality Attributes:
    - [ ] Performance targets achievable
    - [ ] Security requirements addressed
    - [ ] Scalability path is clear
  
  Integration Readiness:
    - [ ] External dependencies identified
    - [ ] Integration patterns selected
    - [ ] Error scenarios considered

Gate Actions:
  PASS: Proceed to Dependency Map
  CONDITIONAL: Refine architecture
  FAIL: Redesign approach
```

## Confidence Scoring

```yaml
Component: "[Architecture Element]"
Confidence Factors:
  Pattern Match: [0-40]
    - Exact pattern used before: 40
    - Similar pattern adapted: 25
    - Novel but researched: 10
  
  Complexity Management: [0-30]
    - Simple, proven approach: 30
    - Moderate complexity: 20
    - High complexity: 10
  
  Risk Level: [0-30]
    - Low risk, proven path: 30
    - Moderate risk, mitigated: 20
    - High risk, accepted: 10

Total: [0-100]
```

## Output

**Location**: `/docs/pre-development/trd/trd-[feature-name].md`

## Next Steps

After Gate 2 approval:
1. TRD becomes technical blueprint
2. Proceed to Dependency Map
3. No technology choices in TRD
4. Keep architecture/implementation separated

## Quality Checklist

- [ ] No specific technology products named
- [ ] All PRD requirements have technical solution
- [ ] Component boundaries follow DDD principles
- [ ] Interfaces are technology-agnostic
- [ ] Data ownership is explicit
- [ ] Security is designed in
- [ ] Performance targets are set
- [ ] Gate 2 criteria met