---
description: Break component architecture into atomic, human-reviewable implementation tasks
globs: 
alwaysApply: false
---
# Rule: Atomic Implementation Tasks

## üß† Enhanced Analysis Tools - USE THESE!

**CRITICAL:** Leverage these tools throughout the atomic task breakdown process:

### üß© Memory MCP Integration
- **Retrieve architecture context:** `memory_search` for component architecture, technical planning, and design specifications
- **Store task logic:** `memory_store_decision` for task breakdown rationale, implementation sequencing, and git workflow strategies
- **Reference implementation patterns:** `memory_search` for similar atomic task structures and successful implementation patterns
- **Track task progress:** `memory_tasks` for atomic implementation workflow management
- **Tags to use:** `["atomic-tasks", "implementation", "git-workflow", "feature-name", "human-ai-pairing"]`

### üîÑ Sequential Thinking MCP
- **Use for:** Complex task decomposition, dependency analysis, implementation sequencing optimization
- **Pattern:** Component architecture ‚Üí atomic boundaries ‚Üí implementation steps ‚Üí git workflow
- **Benefit:** Ensures tasks are perfectly sized for human-AI pair programming and single-session completion
- **When:** During task boundary analysis, dependency mapping, and git workflow planning

**Pro tip:** Store every successful atomic task pattern to improve future task generation for similar components!

## Goal

To guide an AI assistant in analyzing component architecture and creating atomic, human-reviewable implementation tasks that enable effective human-AI pair programming with single-commit development sessions.

## Process

1. **Read Component Architecture:** Load component specifications and integration requirements from previous phase
   - üß© **Memory Action:** `memory_search` to retrieve component architecture decisions and technical specifications

2. **Analyze Implementation Scope:** Extract atomic implementation boundaries from component architecture  
   - üîÑ **Sequential Thinking:** Map component architecture to implementable atomic units

3. **Apply Atomic Task Principles:** Ensure each task matches senior engineer capabilities
   - üîÑ **Sequential Thinking:** Validate task boundaries for ~6 hour completion with comprehensive scope

4. **Generate Atomic Tasks:** Create detailed task specifications with complete git workflow
   - üß© **Memory Action:** `memory_store_decision` for task breakdown rationale and implementation approach

5. **Optional Task Review:** Since tasks directly enable implementation, user review is optional:
   - "I've created atomic implementation tasks. Would you like to review the breakdown, or shall I proceed with saving them?"
   - If user wants to review, WAIT for feedback
   - If user approves or skips review, proceed to save
   - üß© **Memory Action:** `memory_store_chunk` with user feedback (if provided)

6. **Save Atomic Tasks:** Create organized task files in `/docs/frontend-development/tasks/frontend-[feature-name]/`
   - üß© **Memory Action:** `memory_create_thread` completing entire frontend development chain

## Atomic Task Principles for Human-AI Pairing

### Definition of "Atomic Frontend Task"
Each task MUST be:
- **Senior Engineer Scope:** Designed for very senior, highly skilled frontend engineers
- **Full Day Session:** Approximately 6 hours of focused work
- **Component Suite:** Multiple related components, hooks, and integration
- **Human-Reviewable:** Clear deliverables that human can validate thoroughly
- **Single Feature Commit:** Complete feature slice in one comprehensive commit
- **Production-Ready:** Includes implementation, tests, accessibility, performance
- **Self-Contained:** Full vertical slice with UI, logic, tests, and documentation

### Human-AI Pair Programming Optimization
- **Clear Acceptance Criteria:** Human knows exactly what to validate
- **Explicit Integration Points:** How task connects with existing code
- **Testing Requirements:** Unit and integration tests included
- **Error Handling:** Complete error scenarios and user feedback
- **Performance Considerations:** Built-in performance requirements

### Task Validation Checklist
Before finalizing each atomic task, ensure:
- [ ] **Clear Deliverable:** Specific component, feature, or integration point
- [ ] **Human Validation Path:** Clear way for human to test and approve
- [ ] **Integration Specification:** Exact connection points with existing system
- [ ] **Test Coverage:** Complete testing strategy for the task scope
- [ ] **File Size Compliance:** Targets <300 lines, max 500 lines per file
- [ ] **Git Workflow:** Complete branch/commit/PR process included
- [ ] **Error Handling:** Comprehensive error scenarios covered

## Atomic Task Structure

Each generated atomic task should include these sections:

### 1. Task Overview
- **Task ID:** FE-[feature-id]-[number] (e.g., FE-001-001, FE-001-002)
- **Task Name:** Clear, comprehensive name (e.g., "Implement Complete Feature Management UI Suite")
- **Component Focus:** Component suite or feature area this task covers
- **Estimated Duration:** ~6 hours (full day for senior engineer)
- **Implementation Type:** Full Stack Frontend (Components, State, Integration, Tests)
- **Human Review Scope:** Comprehensive review of feature functionality and quality

### üîÄ Git Workflow (REQUIRED FOR EVERY TASK)
**BEFORE STARTING:**
```bash
git checkout main
git pull origin main
git checkout -b feature/FE-[feature-id]-[num]-[short-desc]
# Example: git checkout -b feature/FE-001-001-feature-header
```

**DURING DEVELOPMENT:**
```bash
# Run tests frequently during development
npm test -- --watch
npm run lint
npm run typecheck
```

**AFTER COMPLETING:**
```bash
# Quality validation (REQUIRED)
npm run build              # Ensure production build works
npm test                   # All tests pass
npm run lint              # Code quality check
npm run typecheck         # TypeScript validation
npm run a11y-test         # Accessibility validation (if available)

# Commit with detailed message
git add .
git commit -m "feat(FE-[feature-id]-[num]): [brief description]

Component: [component name and purpose]
Implementation: [key functionality implemented]
Integration: [how it connects with existing components]
Testing: [test coverage and validation]
Accessibility: [a11y considerations implemented]
Quality: All quality checks passed

Files Modified:
- [list of modified files]

Files Added:
- [list of new files]

Human Review Focus:
- [specific areas for human validation]"

git push -u origin feature/FE-[feature-id]-[num]-[short-desc]
```

### 2. Component Implementation Specification

#### Component Requirements
- **Component Name:** [Exact component name and file location]
- **Component Purpose:** [What this component does and why it exists]
- **Props Interface:** [Complete TypeScript interface for component props]
- **State Requirements:** [Local state management needs]
- **Styling Strategy:** [CSS-in-JS, styled-components, or CSS modules approach]

#### Implementation Details
```typescript
// Component interface example
interface ComponentNameProps {
  // Required props
  data: ComponentData;
  onAction: (action: ActionType) => void;
  
  // Optional props
  loading?: boolean;
  error?: string;
  variant?: 'default' | 'compact' | 'expanded';
  className?: string;
  
  // Event handlers
  onClick?: (event: MouseEvent) => void;
  onKeyDown?: (event: KeyboardEvent) => void;
}

// Component data structure
interface ComponentData {
  id: string;
  title: string;
  metadata: Record<string, any>;
  status: 'active' | 'inactive' | 'pending';
}
```

#### File Structure
```
src/components/[ComponentName]/
‚îú‚îÄ‚îÄ index.ts                          # Barrel export
‚îú‚îÄ‚îÄ [ComponentName].tsx               # Main component
‚îú‚îÄ‚îÄ [ComponentName].styles.ts         # Styled components
‚îú‚îÄ‚îÄ [ComponentName].types.ts          # TypeScript types
‚îú‚îÄ‚îÄ [ComponentName].test.tsx          # Unit tests
‚îú‚îÄ‚îÄ [ComponentName].stories.tsx       # Storybook stories
‚îî‚îÄ‚îÄ hooks/
    ‚îî‚îÄ‚îÄ use[ComponentName].ts         # Custom hook (if needed)
```

### 3. Integration Points Specification

#### Existing Code Integration
- **Parent Components:** [Components that will use this component]
- **Child Components:** [Existing components this component will use]
- **State Management:** [How component integrates with global state]
- **API Integration:** [BFF endpoints this component consumes]
- **Event Handling:** [Events this component emits/consumes]

#### BFF/API Integration
```javascript
// API integration example
const useComponentData = (componentId) => {
  return useQuery({
    queryKey: ['component-data', componentId],
    queryFn: () => ComponentAPI.getComponentData(componentId),
    enabled: !!componentId,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};

// Component with API integration
const ComponentName = ({ componentId, onAction }) => {
  const { data, loading, error } = useComponentData(componentId);
  
  if (loading) return <ComponentSkeleton />;
  if (error) return <ComponentError error={error} />;
  if (!data) return <ComponentEmpty />;
  
  return (
    <ComponentContainer>
      {/* Component implementation */}
    </ComponentContainer>
  );
};
```

### 4. Testing Requirements

#### Unit Test Specifications
```javascript
// Comprehensive test coverage
describe('ComponentName', () => {
  const defaultProps = {
    data: mockComponentData,
    onAction: jest.fn(),
  };
  
  describe('Rendering', () => {
    it('renders with required props', () => {
      render(<ComponentName {...defaultProps} />);
      expect(screen.getByRole('button')).toBeInTheDocument();
    });
    
    it('applies variant styling correctly', () => {
      render(<ComponentName {...defaultProps} variant="compact" />);
      expect(screen.getByTestId('component-container')).toHaveClass('compact');
    });
    
    it('handles loading state correctly', () => {
      render(<ComponentName {...defaultProps} loading={true} />);
      expect(screen.getByRole('progressbar')).toBeInTheDocument();
    });
    
    it('handles error state correctly', () => {
      const error = 'Test error message';
      render(<ComponentName {...defaultProps} error={error} />);
      expect(screen.getByRole('alert')).toHaveTextContent(error);
    });
  });
  
  describe('User Interactions', () => {
    it('calls onAction when button is clicked', () => {
      const mockOnAction = jest.fn();
      render(<ComponentName {...defaultProps} onAction={mockOnAction} />);
      
      fireEvent.click(screen.getByRole('button'));
      expect(mockOnAction).toHaveBeenCalledWith(expectedActionData);
    });
    
    it('handles keyboard navigation correctly', () => {
      render(<ComponentName {...defaultProps} />);
      
      const component = screen.getByRole('button');
      fireEvent.keyDown(component, { key: 'Enter' });
      expect(defaultProps.onAction).toHaveBeenCalled();
    });
  });
  
  describe('API Integration', () => {
    it('fetches component data on mount', async () => {
      const mockApiCall = jest.spyOn(ComponentAPI, 'getComponentData');
      render(<ComponentName componentId="test-id" />);
      
      await waitFor(() => {
        expect(mockApiCall).toHaveBeenCalledWith('test-id');
      });
    });
    
    it('handles API errors gracefully', async () => {
      jest.spyOn(ComponentAPI, 'getComponentData').mockRejectedValue(new Error('API Error'));
      
      render(<ComponentName componentId="test-id" />);
      
      await waitFor(() => {
        expect(screen.getByRole('alert')).toBeInTheDocument();
      });
    });
  });
});
```

#### Integration Test Requirements
- **Component Integration:** Test with parent and child components
- **State Management Integration:** Test with global state updates
- **API Integration:** Test with real API responses (mocked)
- **Event Flow:** Test complete user interaction flows

### 5. Accessibility Implementation

#### Accessibility Requirements
```javascript
// Accessibility implementation example
const AccessibleComponent = ({ data, onAction }) => {
  const componentId = `component-${data.id}`;
  const titleId = `title-${data.id}`;
  const descriptionId = `description-${data.id}`;
  
  return (
    <div
      role="article"
      aria-labelledby={titleId}
      aria-describedby={descriptionId}
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onAction(data);
        }
      }}
    >
      <h3 id={titleId}>{data.title}</h3>
      <p id={descriptionId}>{data.description}</p>
      <button
        aria-label={`Action for ${data.title}`}
        onClick={() => onAction(data)}
      >
        Take Action
      </button>
    </div>
  );
};
```

#### A11y Testing Requirements
- **Screen Reader Testing:** NVDA/JAWS compatibility
- **Keyboard Navigation:** Full keyboard accessibility
- **Color Contrast:** WCAG 2.1 AA compliance
- **Focus Management:** Proper focus indicators and management

### 6. Performance Implementation

#### Performance Requirements
```javascript
// Performance optimization example
const OptimizedComponent = memo(({ data, onAction }) => {
  // Memoize expensive calculations
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      displayValue: formatDisplayValue(item.value)
    }));
  }, [data]);
  
  // Memoize event handlers
  const handleAction = useCallback((actionData) => {
    onAction(actionData);
  }, [onAction]);
  
  // Virtualization for large lists
  if (processedData.length > 100) {
    return (
      <VirtualizedList
        data={processedData}
        renderItem={({ item }) => (
          <ComponentItem data={item} onAction={handleAction} />
        )}
        itemHeight={60}
      />
    );
  }
  
  return (
    <ComponentContainer>
      {processedData.map(item => (
        <ComponentItem
          key={item.id}
          data={item}
          onAction={handleAction}
        />
      ))}
    </ComponentContainer>
  );
});
```

#### Performance Validation
- **Rendering Performance:** Component should render in <16ms
- **Memory Usage:** No memory leaks in development tools
- **Bundle Size:** Component should add <50KB to bundle
- **Image Optimization:** All images properly optimized and lazy loaded

### 7. Error Handling Implementation

#### Error Boundary Integration
```javascript
// Component with error handling
const ComponentWithErrorHandling = ({ data, onAction }) => {
  const [error, setError] = useState(null);
  
  const handleError = (error) => {
    setError(error);
    // Log error for monitoring
    errorTracker.captureException(error, {
      component: 'ComponentName',
      data: data.id,
      user: user.id
    });
  };
  
  const retryAction = () => {
    setError(null);
    // Retry logic
  };
  
  if (error) {
    return (
      <ErrorDisplay
        error={error}
        onRetry={retryAction}
        context="ComponentName failed to load"
      />
    );
  }
  
  return (
    <ErrorBoundary onError={handleError}>
      <ComponentImplementation data={data} onAction={onAction} />
    </ErrorBoundary>
  );
};
```

### 8. Human Review Guidelines

#### What Human Should Validate
1. **Visual Design Fidelity:** Component matches design specifications
2. **User Interaction:** All interactions work as expected
3. **Data Integration:** Component displays and updates data correctly
4. **Error Scenarios:** Error states display appropriately
5. **Accessibility:** Component is usable with keyboard and screen reader
6. **Performance:** Component renders smoothly without lag
7. **Responsive Design:** Component works on mobile, tablet, desktop

#### Human Review Checklist
- [ ] **Component renders correctly in all specified variants**
- [ ] **All user interactions trigger expected behaviors**
- [ ] **Loading and error states display appropriately**
- [ ] **Component integrates properly with existing components**
- [ ] **Accessibility features work with keyboard and screen reader**
- [ ] **Component is responsive across breakpoints**
- [ ] **Performance is acceptable (no lag or memory leaks)**
- [ ] **Tests pass and provide adequate coverage**
- [ ] **All quality checks pass (build, lint, typecheck, tests)**

### 9. Quality Assurance Requirements
**CRITICAL:** Each atomic frontend task MUST include comprehensive quality validation:

#### Frontend Quality Checks (REQUIRED)
```bash
# Run after each atomic task completion
npm run build              # Production build verification
npm test                   # Test execution with coverage
npm run lint              # ESLint code quality
npm run typecheck         # TypeScript validation
npm run a11y-test         # Accessibility validation (if available)
npm run bundle-size       # Bundle size analysis (if available)
```

#### Python Backend Integration (if applicable)
```bash
# Run if task includes backend changes
ruff check .              # Linting and formatting
mypy .                   # Type checking
pytest                   # Test execution
black .                  # Code formatting
```

#### Go Backend Integration (if applicable)
```bash
# Run if task includes backend changes
make fmt                 # Code formatting
make vet                 # Static analysis
gosec ./...             # Security analysis
govulncheck ./...       # Vulnerability check
go test ./...           # Test execution
```

#### Quality Gates
Each atomic task must pass ALL quality gates before completion:

1. **Build Quality:** Production build succeeds without warnings
2. **Code Quality:** No linting errors or warnings
3. **Type Safety:** TypeScript compilation succeeds
4. **Test Quality:** All tests pass with >80% coverage
5. **Accessibility:** No a11y violations (WCAG 2.1 AA)
6. **Performance:** Bundle size impact <5% of current size
7. **Integration:** No regression in existing functionality

**FAILURE PROTOCOL:** If any quality check fails:
1. Fix issues immediately before proceeding
2. Document quality violations in memory: `memory_store_chunk` with tag `quality-violation`
3. Re-run complete quality check suite
4. Only mark atomic task as complete when ALL quality checks pass
5. Include quality validation in commit message

### üö® Pre-Emptive Quality Guidance (CRITICAL)

**IMPORTANT:** Use these patterns to avoid common quality check failures in frontend atomic tasks:

#### TypeScript/JavaScript Anti-Patterns to Avoid
**Type Safety:**
```typescript
// ‚ùå WRONG - causes TypeScript violations
const data: any = fetchData();                    // Avoid 'any' type
let config = getConfig();                         // Use const when possible
if (value == null) return;                       // Use strict equality

// ‚úÖ CORRECT - type-safe patterns
interface ComponentData {
    id: string;
    status: 'active' | 'inactive';
    metadata: Record<string, unknown>;
}

const data: ComponentData = await fetchData();   // Explicit typing
const config = getConfig();                      // const for immutable
if (value === null) return;                      // Strict equality
```

**React Component Patterns:**
```typescript
// ‚ùå WRONG - causes lint violations and performance issues
const Component = (props: any) => {              // Avoid any props
    let [state, setState] = useState(null);      // Use const for destructuring
    
    useEffect(() => {
        fetchData().then(data => setState(data)); // Missing dependency
    }, []);
    
    return <div>{state?.value}</div>;
}

// ‚úÖ CORRECT - optimized React patterns
interface ComponentProps {
    id: string;
    onUpdate: (value: string) => void;
    className?: string;
}

const Component: React.FC<ComponentProps> = ({ id, onUpdate, className }) => {
    const [state, setState] = useState<ComponentData | null>(null);
    
    const fetchAndSetData = useCallback(async () => {
        try {
            const data = await fetchData(id);
            setState(data);
        } catch (error) {
            console.error('Failed to fetch data:', error);
        }
    }, [id]);
    
    useEffect(() => {
        fetchAndSetData();
    }, [fetchAndSetData]);
    
    return (
        <div className={className}>
            {state?.value}
        </div>
    );
};
```

**Performance Optimization:**
```typescript
// ‚ùå WRONG - causes performance violations
const ComponentList = ({ items }) => {
    return (
        <div>
            {items.map(item => (
                <ExpensiveComponent 
                    key={item.id} 
                    data={item}
                    onUpdate={() => updateItem(item.id)} // New function every render
                />
            ))}
        </div>
    );
};

// ‚úÖ CORRECT - performance optimized
const ComponentList = React.memo(({ items }: { items: ItemData[] }) => {
    const handleUpdate = useCallback((itemId: string) => {
        updateItem(itemId);
    }, []);
    
    return (
        <div>
            {items.map(item => (
                <ExpensiveComponent 
                    key={item.id} 
                    data={item}
                    onUpdate={handleUpdate}
                />
            ))}
        </div>
    );
});
```

#### CSS/Styling Anti-Patterns
```typescript
// ‚ùå WRONG - causes styling violations
const StyledComponent = styled.div`
    color: #333;                                 // Use CSS variables
    font-size: 16px;                            // Use rem units
    margin: 10px;                               // Use spacing system
`;

// ‚úÖ CORRECT - design system compliant
const StyledComponent = styled.div`
    color: var(--color-text-primary);          // CSS variables
    font-size: var(--font-size-base);          // Design system tokens
    margin: var(--spacing-md);                 // Spacing system
`;
```

#### Accessibility Anti-Patterns
```typescript
// ‚ùå WRONG - causes a11y violations
const Button = ({ onClick, children }) => (
    <div onClick={onClick}>{children}</div>     // Use semantic HTML
);

const Modal = ({ isOpen, children }) => (
    <div style={{ display: isOpen ? 'block' : 'none' }}>
        {children}                              // Missing focus management
    </div>
);

// ‚úÖ CORRECT - accessible patterns
const Button = ({ onClick, children, disabled, ...props }) => (
    <button 
        type="button"
        onClick={onClick}
        disabled={disabled}
        {...props}
    >
        {children}
    </button>
);

const Modal = ({ isOpen, onClose, children, title }) => {
    const modalRef = useRef<HTMLDivElement>(null);
    
    useEffect(() => {
        if (isOpen && modalRef.current) {
            modalRef.current.focus();
        }
    }, [isOpen]);
    
    if (!isOpen) return null;
    
    return (
        <div
            ref={modalRef}
            role="dialog"
            aria-modal="true"
            aria-labelledby="modal-title"
            tabIndex={-1}
        >
            <h2 id="modal-title">{title}</h2>
            {children}
            <button onClick={onClose}>Close</button>
        </div>
    );
};
```

### üéØ Frontend-Specific Quality Strategies

**Keep Components Focused:**
- **Target:** <100 lines per component
- **Maximum:** 150 lines (split if larger)
- **Strategy:** Single responsibility per component

**Component Error Handling:**
```typescript
// ‚úÖ RECOMMENDED pattern for component error handling
const ComponentWithErrorHandling: React.FC<ComponentProps> = (props) => {
    const [error, setError] = useState<Error | null>(null);
    
    if (error) {
        return (
            <ErrorBoundary 
                error={error} 
                onReset={() => setError(null)}
                fallback={<ComponentErrorFallback />}
            />
        );
    }
    
    try {
        return <ComponentImplementation {...props} />;
    } catch (err) {
        setError(err instanceof Error ? err : new Error('Unknown error'));
        return null;
    }
};
```

**State Management Patterns:**
```typescript
// ‚ùå WRONG - state management violations
const Component = () => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    
    // Multiple state updates in different places
    useEffect(() => {
        setLoading(true);
        fetchData().then(result => {
            setData(result);
            setLoading(false);
        }).catch(err => {
            setError(err);
            setLoading(false);
        });
    }, []);
    
    return <div>{/* render logic */}</div>;
};

// ‚úÖ CORRECT - consolidated state management
interface AsyncState<T> {
    data: T | null;
    loading: boolean;
    error: Error | null;
}

const useAsyncData = <T>(fetcher: () => Promise<T>) => {
    const [state, setState] = useState<AsyncState<T>>({
        data: null,
        loading: false,
        error: null
    });
    
    const fetchData = useCallback(async () => {
        setState(prev => ({ ...prev, loading: true, error: null }));
        
        try {
            const data = await fetcher();
            setState({ data, loading: false, error: null });
        } catch (error) {
            setState({ 
                data: null, 
                loading: false, 
                error: error instanceof Error ? error : new Error('Unknown error')
            });
        }
    }, [fetcher]);
    
    return { ...state, refetch: fetchData };
};
```

### üìè Frontend File Size Guidelines

**Optimal Frontend File Sizes:**
- **React components:** <150 lines target, 200 lines maximum
- **Custom hooks:** <100 lines target, 150 lines maximum
- **Utility files:** <200 lines target, 300 lines maximum
- **Style files:** <100 lines target, 150 lines maximum

**Component Decomposition Strategy:**
1. **Split by responsibility** - Logic, presentation, and styling in appropriate files
2. **Extract custom hooks** - Reusable logic in custom hooks
3. **Component composition** - Build complex components from simple ones
4. **Utility extraction** - Common operations in utility functions

### üîç Frontend Pre-Implementation Quality Checklist

Before implementing any atomic frontend task, ensure specification includes:
- [ ] **Type safety** - All props, state, and data properly typed
- [ ] **Performance considerations** - Memoization, virtualization, lazy loading
- [ ] **Accessibility requirements** - WCAG 2.1 AA compliance
- [ ] **Error boundaries** - Proper error handling and user feedback
- [ ] **Testing strategy** - Unit, integration, and accessibility tests
- [ ] **Responsive design** - Mobile, tablet, desktop compatibility
- [ ] **Design system compliance** - Use of design tokens and components
- [ ] **Bundle size impact** - Minimize impact on application bundle

### üîÑ Quality-First Frontend Implementation Flow

**For each atomic frontend task:**
1. **Type interfaces first** - Define all TypeScript interfaces
2. **Write tests before implementation** - TDD approach for better quality
3. **Implement with accessibility** - Build a11y from the start
4. **Test across devices** - Ensure responsive behavior
5. **Validate performance** - Check bundle size and render performance

**Frontend Component Template:**
```typescript
// ‚úÖ RECOMMENDED frontend component template
import React, { useState, useCallback, useEffect } from 'react';
import styled from 'styled-components';

// Type definitions
interface ComponentProps {
    id: string;
    data: ComponentData;
    onUpdate: (id: string, data: ComponentData) => void;
    variant?: 'default' | 'compact' | 'expanded';
    className?: string;
    'data-testid'?: string;
}

interface ComponentData {
    title: string;
    status: 'active' | 'inactive' | 'pending';
    metadata: Record<string, unknown>;
}

// Styled components
const ComponentContainer = styled.div<{ variant: string }>`
    display: flex;
    flex-direction: column;
    padding: var(--spacing-md);
    border-radius: var(--border-radius-md);
    background-color: var(--color-background-primary);
    
    ${({ variant }) => variant === 'compact' && `
        padding: var(--spacing-sm);
    `}
    
    ${({ variant }) => variant === 'expanded' && `
        padding: var(--spacing-lg);
    `}
`;

// Main component
const Component: React.FC<ComponentProps> = ({
    id,
    data,
    onUpdate,
    variant = 'default',
    className,
    'data-testid': testId = 'component'
}) => {
    const [isProcessing, setIsProcessing] = useState(false);
    
    const handleUpdate = useCallback(async () => {
        setIsProcessing(true);
        
        try {
            await onUpdate(id, data);
        } catch (error) {
            console.error('Update failed:', error);
        } finally {
            setIsProcessing(false);
        }
    }, [id, data, onUpdate]);
    
    return (
        <ComponentContainer 
            variant={variant}
            className={className}
            data-testid={testId}
            role="article"
            aria-busy={isProcessing}
        >
            <h3>{data.title}</h3>
            <p>Status: {data.status}</p>
            <button 
                type="button"
                onClick={handleUpdate}
                disabled={isProcessing}
                aria-label={`Update ${data.title}`}
            >
                {isProcessing ? 'Updating...' : 'Update'}
            </button>
        </ComponentContainer>
    );
};

export default React.memo(Component);
export type { ComponentProps, ComponentData };
```

### üß™ Frontend Testing Template
```typescript
// ‚úÖ RECOMMENDED frontend test template
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { axe, toHaveNoViolations } from 'jest-axe';

import Component from './Component';
import type { ComponentProps } from './Component';

expect.extend(toHaveNoViolations);

const defaultProps: ComponentProps = {
    id: 'test-id',
    data: {
        title: 'Test Component',
        status: 'active',
        metadata: {}
    },
    onUpdate: jest.fn()
};

describe('Component', () => {
    describe('Rendering', () => {
        it('renders with required props', () => {
            render(<Component {...defaultProps} />);
            
            expect(screen.getByText('Test Component')).toBeInTheDocument();
            expect(screen.getByText('Status: active')).toBeInTheDocument();
        });
        
        it('applies variant styling correctly', () => {
            render(<Component {...defaultProps} variant="compact" />);
            
            const container = screen.getByTestId('component');
            expect(container).toHaveClass('compact');
        });
    });
    
    describe('User Interactions', () => {
        it('calls onUpdate when update button is clicked', async () => {
            const mockOnUpdate = jest.fn();
            render(<Component {...defaultProps} onUpdate={mockOnUpdate} />);
            
            const updateButton = screen.getByRole('button', { name: /update test component/i });
            fireEvent.click(updateButton);
            
            await waitFor(() => {
                expect(mockOnUpdate).toHaveBeenCalledWith('test-id', defaultProps.data);
            });
        });
        
        it('handles keyboard navigation correctly', async () => {
            const user = userEvent.setup();
            render(<Component {...defaultProps} />);
            
            const updateButton = screen.getByRole('button');
            await user.tab();
            expect(updateButton).toHaveFocus();
            
            await user.keyboard('{Enter}');
            expect(defaultProps.onUpdate).toHaveBeenCalled();
        });
    });
    
    describe('Accessibility', () => {
        it('has no accessibility violations', async () => {
            const { container } = render(<Component {...defaultProps} />);
            const results = await axe(container);
            expect(results).toHaveNoViolations();
        });
        
        it('provides proper ARIA labels', () => {
            render(<Component {...defaultProps} />);
            
            expect(screen.getByRole('article')).toBeInTheDocument();
            expect(screen.getByRole('button')).toHaveAccessibleName('Update Test Component');
        });
    });
    
    describe('Error States', () => {
        it('handles update errors gracefully', async () => {
            const mockOnUpdate = jest.fn().mockRejectedValue(new Error('Update failed'));
            render(<Component {...defaultProps} onUpdate={mockOnUpdate} />);
            
            const updateButton = screen.getByRole('button');
            fireEvent.click(updateButton);
            
            await waitFor(() => {
                expect(updateButton).not.toBeDisabled();
            });
        });
    });
});
```

### üß† Required Memory Actions During Implementation

**CRITICAL:** Every atomic task implementation MUST include these Memory MCP actions:

**Before Starting Implementation:**
```
memory_store_chunk
  content="Starting FE-[ID]: [task-name]. Component: [component-name]. Integration context: [existing components involved]"
  tags=["atomic-task", "started", "FE-[ID]", "component-name", "feature-name"]
  session_id="[current-session]"
  repository="[project-repo]"
```

**During Implementation (for complex decisions):**
```
memory_store_decision
  decision="[key implementation or integration choice]"
  rationale="[why this approach works with existing components and user requirements]"
  alternatives="[other approaches considered and why this was chosen]"
  session_id="[current-session]"
  repository="[project-repo]"
```

**After Completion:**
```
memory_store_chunk
  content="Completed FE-[ID]: [summary]. Integration success: [how it works with existing system]. Testing: [test coverage achieved]. Performance: [performance characteristics]. Human review notes: [areas for human focus]"
  tags=["atomic-task", "completed", "FE-[ID]", "integration-success", "component-ready"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### üîÑ Sequential Thinking for Complex Components
**RECOMMENDED:** For complex component implementation decisions, use Sequential Thinking MCP:
```
mcp__sequential-thinking__sequentialthinking
  thought="[complex component or integration challenge]"
  thought_number=1
  total_thoughts=3-5
  next_thought_needed=true
```
Use when facing:
- Complex component state management
- Challenging integration with existing components
- Performance optimization decisions
- Accessibility implementation complexity

## Atomic Task Examples

### Example 1: Comprehensive Feature UI Implementation

```markdown
## FE-001-001: Implement Complete Feature Management UI Suite

### 1. Task Overview
- **Task ID:** FE-001-001
- **Task Name:** Implement Complete Feature Management UI Suite
- **Component Focus:** Feature header, navigation, list view, detail view, and actions
- **Estimated Duration:** ~6 hours (full day for senior engineer)
- **Implementation Type:** Full Stack Frontend (5 Components, State Management, API Integration, Tests)
- **Human Review Scope:** Complete feature workflow, visual consistency, performance, accessibility

### üîÄ Git Workflow (REQUIRED)
**BEFORE STARTING:**
```bash
git checkout main
git pull origin main
git checkout -b feature/FE-001-001-feature-management-ui
```

**AFTER COMPLETING:**
```bash
npm run build && npm test && npm run lint && npm run a11y-test
git add .
git commit -m "feat(FE-001-001): implement complete feature management UI suite

Components Implemented:
- FeatureHeader: Navigation, actions, responsive design
- FeatureList: Virtualized list with filtering and sorting
- FeatureDetail: Detail view with edit capabilities
- FeatureActions: Action toolbar with bulk operations
- FeatureProvider: State management and API integration

Implementation Details:
- Full responsive design (mobile, tablet, desktop)
- Optimistic UI updates with rollback
- Real-time data synchronization
- Comprehensive error handling
- Loading and empty states

Testing:
- Unit tests for all components (95% coverage)
- Integration tests for data flow
- Accessibility tests pass WCAG 2.1 AA
- Performance tests validate smooth scrolling

Files Added:
- src/components/Feature/[5 component directories]
- src/hooks/useFeature.ts
- src/services/featureService.ts
- src/types/feature.types.ts
- src/utils/featureHelpers.ts

Human Review Focus:
- Complete feature workflow end-to-end
- Visual consistency across all breakpoints
- Performance with large datasets
- Accessibility with screen reader
- Error recovery scenarios"

git push -u origin feature/FE-001-001-feature-management-ui
```

### 2. Component Implementation Specification

#### Component Suite Overview
**Five interconnected components forming complete feature management UI:**

1. **FeatureHeader** - Navigation and primary actions
2. **FeatureList** - Main list view with virtualization
3. **FeatureDetail** - Detail/edit view with forms
4. **FeatureActions** - Bulk operations toolbar
5. **FeatureProvider** - State management wrapper

#### Shared Type Definitions
```typescript
// Core feature types used across all components
interface Feature {
  id: string;
  name: string;
  description: string;
  status: 'active' | 'inactive' | 'pending';
  priority: 'low' | 'medium' | 'high';
  metadata: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

interface FeatureContextValue {
  features: Feature[];
  selectedFeatures: Set<string>;
  loading: boolean;
  error: Error | null;
  filters: FeatureFilters;
  sorting: SortConfig;
  actions: {
    createFeature: (data: CreateFeatureData) => Promise<void>;
    updateFeature: (id: string, data: UpdateFeatureData) => Promise<void>;
    deleteFeatures: (ids: string[]) => Promise<void>;
    selectFeature: (id: string) => void;
    setFilters: (filters: FeatureFilters) => void;
    setSorting: (config: SortConfig) => void;
  };
}
```

### 3. Integration Points Specification
- **State Management:** All components wrapped in FeatureProvider for shared state
- **API Integration:** FeatureService handles all backend communication
- **Design System:** Uses existing Button, Input, Table, Modal components
- **Routing:** Integrates with React Router for detail views
- **Real-time Updates:** WebSocket integration for live data updates
- **Error Boundaries:** Comprehensive error handling at component level

### 4. Testing Requirements
```javascript
// Example of comprehensive test suite structure
describe('Feature Management UI Suite', () => {
  describe('FeatureProvider', () => {
    it('provides context to all child components', () => {
      // Test context provision
    });
    it('handles API errors gracefully', () => {
      // Test error states
    });
  });

  describe('FeatureList', () => {
    it('renders virtualized list efficiently', () => {
      // Test with 1000+ items
    });
    it('filters and sorts correctly', () => {
      // Test all filter/sort combinations
    });
    it('handles selection for bulk operations', () => {
      // Test multi-select behavior
    });
  });

  describe('FeatureDetail', () => {
    it('validates form inputs correctly', () => {
      // Test all validation rules
    });
    it('handles optimistic updates', () => {
      // Test update/rollback flow
    });
  });

  describe('Integration Tests', () => {
    it('completes full CRUD workflow', () => {
      // Test create, read, update, delete
    });
    it('maintains data consistency across components', () => {
      // Test state synchronization
    });
  });

  describe('Accessibility', () => {
    it('supports full keyboard navigation', () => {
      // Test all keyboard interactions
    });
    it('announces changes to screen readers', () => {
      // Test ARIA live regions
    });
  });

  describe('Performance', () => {
    it('renders large lists without lag', () => {
      // Benchmark with 10,000 items
    });
    it('handles rapid user interactions', () => {
      // Test debouncing/throttling
    });
  });
});
```

### 5. Human Review Guidelines
**Comprehensive Review Areas:**

1. **Feature Workflow Validation:**
   - Complete CRUD operations work end-to-end
   - Data persists correctly across page refreshes
   - Real-time updates reflect immediately
   - Bulk operations handle edge cases

2. **Visual Design Consistency:**
   - All components follow design system
   - Responsive behavior smooth at all breakpoints
   - Loading states provide good UX
   - Error states are clear and actionable

3. **Performance Validation:**
   - List scrolling smooth with 1000+ items
   - No memory leaks during extended use
   - API calls properly debounced/throttled
   - Bundle size impact acceptable

4. **Accessibility Testing:**
   - Full keyboard navigation works
   - Screen reader announces all changes
   - Focus management correct in modals
   - Color contrast meets WCAG 2.1 AA

5. **Error Recovery:**
   - Network failures handled gracefully
   - Optimistic updates roll back correctly
   - Form validation prevents bad data
   - Error messages guide users to resolution

**Success Criteria Checklist:**
- [ ] All 5 components render and integrate correctly
- [ ] Feature CRUD operations work completely
- [ ] Performance benchmarks met (list renders <16ms)
- [ ] Accessibility audit passes with no violations
- [ ] All automated tests pass (>90% coverage)
- [ ] No console errors or warnings
- [ ] Memory usage stable over time
- [ ] Works in all supported browsers
```

### Example 2: Comprehensive Data Management Implementation

```markdown
## FE-001-002: Implement Complete Data Layer with Real-time Sync

### 1. Task Overview
- **Task ID:** FE-001-002
- **Task Name:** Implement Complete Data Layer with Real-time Sync
- **Component Focus:** API integration, state management, caching, real-time updates
- **Estimated Duration:** ~6 hours (full day for senior engineer)
- **Implementation Type:** Full Stack Data Layer (API, WebSocket, State, Cache, Sync)
- **Human Review Scope:** Data consistency, performance, error recovery, real-time behavior

### 2. Complete Data Layer Implementation
```javascript
// Comprehensive data management solution
class FeatureDataManager {
  constructor() {
    this.queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          staleTime: 5 * 60 * 1000,
          cacheTime: 10 * 60 * 1000,
          retry: 3,
          retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
        }
      }
    });
    
    this.websocket = new WebSocketClient({
      url: process.env.REACT_APP_WS_URL,
      reconnect: true,
      heartbeat: 30000,
    });
    
    this.setupRealTimeSync();
  }

  // API integration with optimistic updates
  async updateFeature(id, data) {
    const previousData = this.queryClient.getQueryData(['features']);
    
    // Optimistic update
    this.queryClient.setQueryData(['features'], old => ({
      ...old,
      items: old.items.map(item => 
        item.id === id ? { ...item, ...data } : item
      )
    }));
    
    try {
      const result = await FeatureAPI.update(id, data);
      this.broadcastUpdate('feature.updated', result);
      return result;
    } catch (error) {
      // Rollback on error
      this.queryClient.setQueryData(['features'], previousData);
      this.handleError(error);
      throw error;
    }
  }

  // Real-time synchronization
  setupRealTimeSync() {
    this.websocket.on('feature.created', (data) => {
      this.queryClient.invalidateQueries(['features']);
      this.notifyUser('New feature added', data);
    });
    
    this.websocket.on('feature.updated', (data) => {
      this.queryClient.setQueryData(['features'], old => ({
        ...old,
        items: old.items.map(item => 
          item.id === data.id ? data : item
        )
      }));
    });
    
    this.websocket.on('feature.deleted', (data) => {
      this.queryClient.setQueryData(['features'], old => ({
        ...old,
        items: old.items.filter(item => item.id !== data.id)
      }));
    });
  }

  // Offline support
  async syncOfflineChanges() {
    const pendingChanges = await this.getOfflineQueue();
    
    for (const change of pendingChanges) {
      try {
        await this.processOfflineChange(change);
        await this.removeFromOfflineQueue(change.id);
      } catch (error) {
        console.error('Failed to sync offline change:', change, error);
      }
    }
  }

  // Advanced caching strategies
  prefetchRelatedData(featureId) {
    // Prefetch related data that user might need
    this.queryClient.prefetchQuery(
      ['feature-details', featureId],
      () => FeatureAPI.getDetails(featureId)
    );
    
    this.queryClient.prefetchQuery(
      ['feature-history', featureId],
      () => FeatureAPI.getHistory(featureId)
    );
  }
}

// Custom hooks for data access
export const useFeatures = (filters) => {
  const manager = useContext(DataManagerContext);
  
  return useQuery({
    queryKey: ['features', filters],
    queryFn: () => FeatureAPI.list(filters),
    onSuccess: (data) => {
      // Prefetch details for visible items
      data.items.slice(0, 10).forEach(item => {
        manager.prefetchRelatedData(item.id);
      });
    }
  });
};

export const useFeatureSubscription = (featureId) => {
  const queryClient = useQueryClient();
  
  useEffect(() => {
    const unsubscribe = websocket.subscribe(`feature.${featureId}`, (event) => {
      queryClient.invalidateQueries(['feature-details', featureId]);
    });
    
    return unsubscribe;
  }, [featureId]);
};
```

### 3. Human Review Guidelines
**Comprehensive Data Layer Review:**

1. **API Integration:**
   - All CRUD operations work correctly
   - Optimistic updates provide instant feedback
   - Rollback works on failures
   - Error retry logic functions properly

2. **Real-time Synchronization:**
   - WebSocket connection stays stable
   - Updates propagate to all users
   - Reconnection works after network issues
   - No duplicate or lost messages

3. **Performance & Caching:**
   - Data loads quickly from cache
   - Prefetching improves perceived performance
   - Memory usage stays reasonable
   - No unnecessary API calls

4. **Offline Support:**
   - Changes queue when offline
   - Sync happens automatically on reconnection
   - Conflict resolution works correctly
   - No data loss during offline periods

5. **Error Handling:**
   - All error scenarios handled gracefully
   - User gets clear feedback
   - System recovers automatically when possible
   - Error tracking captures issues

**Success Criteria:**
- [ ] Complete data CRUD operations work
- [ ] Real-time sync updates all clients
- [ ] Offline changes sync when online
- [ ] Performance metrics met (<100ms for cached data)
- [ ] Error recovery works in all scenarios
- [ ] Memory usage stable over time
- [ ] All tests pass (>90% coverage)
```

## Implementation Plan Structure

Create organized implementation plan:

```
docs/frontend-development/tasks/frontend-[feature-name]/
‚îú‚îÄ‚îÄ overview.md                           # Implementation overview
‚îú‚îÄ‚îÄ FE-[feature-id]-001-[task-name].md    # Individual atomic tasks
‚îú‚îÄ‚îÄ FE-[feature-id]-002-[task-name].md
‚îú‚îÄ‚îÄ FE-[feature-id]-003-[task-name].md
‚îú‚îÄ‚îÄ FE-[feature-id]-004-[task-name].md
‚îî‚îÄ‚îÄ implementation-sequence.md             # Task execution order and dependencies
```

### Overview Document Structure

```markdown
# Frontend Implementation Plan: [Feature Name]

## üéØ Implementation Overview

**Feature:** [Feature name]
**Total Tasks:** [Number of atomic tasks]
**Estimated Duration:** [Total development time across all tasks]
**Human-AI Session Count:** [Number of pair programming sessions needed]

## üìã Atomic Task Summary

| Task ID | Name | Duration | Type | Dependencies | Human Review Focus |
|---------|------|----------|------|--------------|--------------------|
| FE-001-001 | Complete Feature UI Suite | 6h | Full Stack | None | Complete workflow, performance |
| FE-001-002 | Data Layer with Real-time | 6h | Integration | None | Data consistency, sync |
| FE-001-003 | Advanced Features & Polish | 6h | Enhancement | FE-001-001,002 | UX polish, edge cases |

## üîó Component Integration Map

```mermaid
graph TD
    A[FE-001-001: FeatureHeader] -->|Used by| B[FE-001-004: FeatureLayout]
    C[FE-001-002: DataList] -->|Used by| B
    D[FE-001-003: API Integration] -->|Provides data to| C
    B -->|Integrates with| E[Existing App Layout]
```

## üìÖ Implementation Sequence

### Week 1: Core Implementation
- **Day 1 (6h):** FE-001-001 - Complete Feature UI Suite
  - Morning: Component architecture and state design
  - Afternoon: Implementation and testing
  
- **Day 2 (6h):** FE-001-002 - Data Layer with Real-time Sync
  - Morning: API integration and caching
  - Afternoon: WebSocket and offline support

- **Day 3 (6h):** FE-001-003 - Advanced Features & Polish
  - Morning: Performance optimization
  - Afternoon: Accessibility and final polish

### Total: 18 hours (3 full days for senior engineer)

### Parallel Opportunities
- **Styling tasks** can be done in parallel with component logic
- **Testing tasks** can be started as soon as component logic is complete
- **Accessibility implementation** can be done incrementally

### Critical Path
- **FE-001-001 ‚Üí FE-001-004:** Header must exist before layout integration
- **FE-001-002 ‚Üí FE-001-003:** DataList component needed before API integration
- **FE-001-003 ‚Üí FE-001-006:** API integration must be complete before final testing
```

## Memory Actions During Process

### Initial Context Retrieval
```
memory_search "component-architecture design-analysis technical-planning [feature-name]" repository="[project-repo]"
memory_store_chunk
  content="Starting atomic task breakdown for [feature-name]. Architecture context: [component summary]. Technical context: [integration summary]"
  tags=["atomic-tasks", "started", "feature-name", "implementation-planning"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### After Task Generation
```
memory_store_decision
  decision="Atomic task breakdown for [feature-name]"
  rationale="Task boundaries based on component architecture. Human-AI pairing optimized for 2-4 hour sessions. Integration approach: [approach]. Git workflow: single commit per task."
  context="Total tasks: [count]. Component tasks: [count]. Integration tasks: [count]. Testing tasks: [count]. Critical path: [tasks]"
  session_id="[current-session]"
  repository="[project-repo]"
```

### After Plan Completion
```
memory_create_thread
  name="Frontend Atomic Implementation: [feature-name]"
  description="Complete frontend development from design analysis through atomic implementation tasks"
  chunk_ids=["[design-analysis-chunks]", "[tech-planning-chunks]", "[component-architecture-chunks]", "[atomic-tasks-chunks]"]
  repository="[project-repo]"
```

## Quality Validation

Before finalizing atomic task breakdown, ensure:

### Task Atomicity Validation
- [ ] **Each task completable in single ~6 hour session by senior engineer**
- [ ] **Each task produces complete feature slice with all components**
- [ ] **Tasks deliver production-ready functionality**
- [ ] **Dependencies are logical and support efficient development**

### Human-AI Pairing Optimization
- [ ] **Clear acceptance criteria for human validation**
- [ ] **Explicit integration points documented**
- [ ] **Complete git workflow included**
- [ ] **Error handling fully specified**

### Implementation Quality
- [ ] **All tasks follow established coding standards**
- [ ] **Performance requirements built into each task**
- [ ] **Accessibility requirements included**
- [ ] **Testing coverage is comprehensive**

### Development Workflow Integration
- [ ] **Git workflow supports code review process**
- [ ] **Task sequence optimizes development efficiency**
- [ ] **Parallel work opportunities identified**
- [ ] **Critical path clearly documented**

## Final Instructions

1. **Senior Engineer Focus** - Every task designed for ~6 hours by highly skilled engineers
2. **Comprehensive Scope** - Each task delivers complete feature slice with all necessary parts
3. **Production Ready** - Tasks include implementation, tests, docs, and quality validation
4. **Human-Centric** - Clear deliverables for thorough human review and validation
5. **Git Discipline** - Every task includes complete git workflow with detailed commits
6. **Quality Built-In** - Testing, accessibility, and performance included in every task
7. **Memory Integration** - Store all task breakdown decisions and successful patterns

This atomic task breakdown optimizes for senior engineer efficiency while maintaining high quality and comprehensive feature delivery.