---
description: Design detailed component structure and BFF integration architecture
globs: 
alwaysApply: false
---
# Rule: Component Integration Architecture

## ðŸ§  Enhanced Analysis Tools - USE THESE!

**CRITICAL:** Leverage these tools throughout the component architecture design process:

### ðŸ§© Memory MCP Integration
- **Retrieve architecture context:** `memory_search` for design analysis and technical planning from previous phases
- **Store architecture decisions:** `memory_store_decision` for component structure, integration patterns, and data flow designs
- **Reference component patterns:** `memory_search` for existing component architectures and successful integration patterns
- **Track architecture process:** `memory_tasks` for component architecture workflow management
- **Tags to use:** `["component-architecture", "integration-design", "data-flow", "feature-name", "bff-integration"]`

### ðŸ”„ Sequential Thinking MCP
- **Use for:** Component hierarchy analysis, data flow design, integration pattern selection
- **Pattern:** Technical plan â†’ component breakdown â†’ data flow â†’ integration architecture
- **Benefit:** Ensures component design is optimal for both user experience and system integration
- **When:** During component hierarchy design and integration pattern analysis

**Pro tip:** Always reference existing component patterns to ensure architectural consistency and reusability!

## Goal

To guide an AI assistant in designing detailed component architecture and BFF integration patterns that convert technical plans into implementable component specifications with clear data flow and integration points.

## Process

1. **Read Previous Phases:** Load design analysis and technical planning from previous phases
   - ðŸ§© **Memory Action:** `memory_search` to retrieve design specifications and technical decisions

2. **Analyze Component Requirements:** Extract component needs from design and technical specifications
   - ðŸ”„ **Sequential Thinking:** Map design elements to component architecture requirements

3. **Design Component Hierarchy:** Create detailed component structure and relationships
   - ðŸ”„ **Sequential Thinking:** Optimize component boundaries for reusability and maintainability

4. **Design Integration Architecture:** Plan BFF integration patterns and data flow
   - ðŸ”„ **Sequential Thinking:** Ensure integration patterns support scalability and performance

5. **Ask Architecture Questions:** Gather specific architectural preferences (Optional)
   - Focus on component boundaries, data flow patterns, and integration strategies
   - **Note:** This phase can be automated based on previous phases if clear enough

6. **Generate Component Architecture:** Create comprehensive component and integration specifications
   - ðŸ§© **Memory Action:** `memory_store_decision` for key architectural choices and rationale

7. **Optional Architecture Review:** Present architecture and ask for feedback (if complex):
   - "I've designed the component architecture. Would you like to review it, or shall I proceed?"
   - If user wants review, WAIT for feedback
   - ðŸ§© **Memory Action:** `memory_store_chunk` with user architectural feedback

8. **Save Component Architecture:** Save as `component-integration-[feature-name].md` in `/docs/frontend-development/`
   - ðŸ§© **Memory Action:** Link all previous phases in memory thread

## Component Architecture Structure

Create component architecture using this structure:

```markdown
# Component Integration Architecture: [Feature Name]

## ðŸ—ï¸ Component Architecture Overview

**Feature:** [Feature name from previous phases]
**Architecture Complexity:** [Simple/Moderate/Complex based on component hierarchy]
**Integration Points:** [Number and types of BFF/system integrations]
**Reusability Score:** [High/Medium/Low - how many components can be reused]

## ðŸ“‹ Component Hierarchy Design

### Component Tree Structure
```
FeatureRoot/                          # Root container component
â”œâ”€â”€ FeatureProvider/                  # Context/state provider
â”‚   â”œâ”€â”€ FeatureHeader/               # Feature header with navigation
â”‚   â”‚   â”œâ”€â”€ FeatureTitleBar/        # Title and primary actions
â”‚   â”‚   â”œâ”€â”€ FeatureNavigation/      # Feature-specific navigation
â”‚   â”‚   â””â”€â”€ FeatureActions/         # Primary action buttons
â”‚   â”œâ”€â”€ FeatureContent/             # Main content area
â”‚   â”‚   â”œâ”€â”€ FeatureDataDisplay/     # Data visualization components
â”‚   â”‚   â”‚   â”œâ”€â”€ DataList/           # List/table data display
â”‚   â”‚   â”‚   â”œâ”€â”€ DataCard/           # Card-based data display
â”‚   â”‚   â”‚   â””â”€â”€ DataChart/          # Chart/graph components
â”‚   â”‚   â”œâ”€â”€ FeatureInteraction/     # Interactive components
â”‚   â”‚   â”‚   â”œâ”€â”€ FeatureForm/        # Form components
â”‚   â”‚   â”‚   â”œâ”€â”€ FeatureFilters/     # Filtering and search
â”‚   â”‚   â”‚   â””â”€â”€ FeatureControls/    # Control components
â”‚   â”‚   â””â”€â”€ FeatureModals/          # Modal dialogs
â”‚   â””â”€â”€ FeatureFooter/              # Feature footer/actions
â”œâ”€â”€ FeatureLoading/                  # Loading states
â”œâ”€â”€ FeatureError/                    # Error boundaries and displays
â””â”€â”€ FeatureEmpty/                    # Empty states
```

### Component Responsibility Matrix

| Component | Responsibility | State Management | Data Dependencies |
|-----------|---------------|------------------|-------------------|
| **FeatureRoot** | Layout orchestration, error boundaries | None - delegates | None |
| **FeatureProvider** | Context/state management, data fetching | Global feature state | BFF API integration |
| **FeatureHeader** | Feature navigation and primary actions | Local UI state | User context |
| **FeatureContent** | Content layout and component coordination | Local layout state | Feature data from provider |
| **DataDisplay** | Data presentation and visualization | Local display state | Formatted data from parent |
| **FeatureInteraction** | User input and interaction handling | Local form state | Form validation, submission |
| **FeatureModals** | Modal state and dialog management | Local modal state | Context from feature provider |

## ðŸ”— Component Interface Design

### Core Component Interfaces
```typescript
// Root container component
interface FeatureRootProps {
  featureId: string;
  initialData?: FeatureData;
  onError?: (error: Error) => void;
  className?: string;
}

// Provider component for state management
interface FeatureProviderProps {
  children: React.ReactNode;
  featureConfig: FeatureConfig;
  apiClient: BFFClient;
}

// Main content components
interface FeatureContentProps {
  data: FeatureData;
  loading: boolean;
  error?: string;
  onDataAction: (action: DataAction) => void;
  variant?: 'default' | 'compact' | 'detailed';
}

// Data display components
interface DataDisplayProps {
  data: DisplayData[];
  columns?: ColumnConfig[];
  sorting?: SortConfig;
  pagination?: PaginationConfig;
  onSort?: (column: string, direction: 'asc' | 'desc') => void;
  onPaginate?: (page: number, size: number) => void;
}

// Interactive components
interface FeatureInteractionProps {
  onSubmit: (data: FormData) => Promise<void>;
  initialValues?: Partial<FormData>;
  validation?: ValidationSchema;
  disabled?: boolean;
}
```

### Data Flow Interfaces
```typescript
// Feature-level data structures
interface FeatureData {
  id: string;
  metadata: FeatureMetadata;
  content: FeatureContent;
  status: 'loading' | 'ready' | 'error';
  lastUpdated: string;
}

// BFF integration data contracts
interface BFFResponse<T> {
  data: T;
  metadata: {
    page?: number;
    totalCount?: number;
    hasMore?: boolean;
  };
  status: 'success' | 'error';
  message?: string;
}

// Action types for state management
type FeatureAction = 
  | { type: 'FETCH_START' }
  | { type: 'FETCH_SUCCESS'; payload: FeatureData }
  | { type: 'FETCH_ERROR'; payload: string }
  | { type: 'UPDATE_ITEM'; payload: { id: string; updates: Partial<FeatureData> } }
  | { type: 'DELETE_ITEM'; payload: string };
```

## ðŸ”„ State Management Architecture

### State Management Strategy
```javascript
// Feature-level state management with Context + Reducer
const FeatureContext = createContext();

const featureReducer = (state, action) => {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    
    case 'FETCH_SUCCESS':
      return { 
        ...state, 
        loading: false, 
        data: action.payload,
        lastFetch: Date.now()
      };
    
    case 'FETCH_ERROR':
      return { 
        ...state, 
        loading: false, 
        error: action.payload 
      };
    
    case 'UPDATE_ITEM':
      return {
        ...state,
        data: {
          ...state.data,
          items: state.data.items.map(item =>
            item.id === action.payload.id 
              ? { ...item, ...action.payload.updates }
              : item
          )
        }
      };
    
    default:
      return state;
  }
};

// Custom hook for feature state management
const useFeatureState = () => {
  const context = useContext(FeatureContext);
  if (!context) {
    throw new Error('useFeatureState must be used within FeatureProvider');
  }
  return context;
};
```

### Component State Boundaries
- **Global Feature State:** Data fetched from BFF, user permissions, feature configuration
- **Shared Component State:** UI state that affects multiple components (filters, search)
- **Local Component State:** Form inputs, local UI toggles, component-specific display state
- **Derived State:** Computed values from global state (filtered lists, calculated totals)

### State Synchronization Strategy
```javascript
// Optimistic updates for better UX
const useOptimisticUpdate = () => {
  const { state, dispatch } = useFeatureState();
  
  const updateItem = async (id, updates) => {
    // Optimistic update
    dispatch({ type: 'UPDATE_ITEM', payload: { id, updates } });
    
    try {
      // API call
      const result = await FeatureAPI.updateItem(id, updates);
      
      // Confirm with server data
      dispatch({ type: 'UPDATE_ITEM', payload: { id, updates: result.data } });
    } catch (error) {
      // Revert optimistic update
      dispatch({ type: 'FETCH_DATA' }); // Re-fetch to get current state
      throw error;
    }
  };
  
  return { updateItem };
};
```

## ðŸ”Œ BFF Integration Architecture

### API Service Layer Design
```javascript
// Centralized API service for feature
class FeatureAPIService {
  constructor(bffClient) {
    this.client = bffClient;
    this.baseURL = '/api/v1/feature';
  }
  
  // Data fetching methods
  async getFeatureData(params = {}) {
    const response = await this.client.get(`${this.baseURL}/data`, { 
      params,
      timeout: 10000
    });
    return this.normalizeResponse(response.data);
  }
  
  async getFeatureList(filters = {}) {
    const response = await this.client.get(`${this.baseURL}/list`, {
      params: { ...filters, page: filters.page || 1, limit: filters.limit || 20 }
    });
    return this.normalizeListResponse(response.data);
  }
  
  // Data mutation methods
  async createFeatureItem(data) {
    const response = await this.client.post(`${this.baseURL}/items`, {
      ...data,
      timestamp: new Date().toISOString()
    });
    return this.normalizeResponse(response.data);
  }
  
  async updateFeatureItem(id, updates) {
    const response = await this.client.put(`${this.baseURL}/items/${id}`, {
      ...updates,
      lastModified: new Date().toISOString()
    });
    return this.normalizeResponse(response.data);
  }
  
  async deleteFeatureItem(id) {
    await this.client.delete(`${this.baseURL}/items/${id}`);
    return { success: true, deletedId: id };
  }
  
  // Real-time features
  subscribeToUpdates(callback) {
    const ws = new WebSocket(`${process.env.REACT_APP_WS_URL}/feature-updates`);
    ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      callback(this.normalizeResponse(update));
    };
    return () => ws.close();
  }
  
  // Response normalization
  normalizeResponse(data) {
    return {
      ...data,
      // Ensure consistent date formats
      createdAt: new Date(data.created_at || data.createdAt),
      updatedAt: new Date(data.updated_at || data.updatedAt),
      // Normalize nested objects
      metadata: data.metadata || {},
    };
  }
  
  normalizeListResponse(data) {
    return {
      items: data.items.map(item => this.normalizeResponse(item)),
      pagination: {
        page: data.page || 1,
        totalCount: data.total_count || data.totalCount,
        hasMore: data.has_more || data.hasMore,
        limit: data.limit || 20
      }
    };
  }
}
```

### Data Flow Architecture
```mermaid
sequenceDiagram
    participant UI as React Component
    participant State as Feature State
    participant API as API Service
    participant BFF as BFF Layer
    participant Cache as Cache Layer
    
    UI->>State: User action triggers
    State->>API: API service call
    API->>Cache: Check cache first
    Cache-->>API: Cache miss/expired
    API->>BFF: HTTP request with auth
    BFF-->>API: Formatted response
    API->>Cache: Store in cache
    API-->>State: Normalized data
    State->>State: Update state
    State-->>UI: Re-render with new data
```

### Error Handling Strategy
```javascript
// Comprehensive error handling
const useAPIErrorHandler = () => {
  const showNotification = useNotification();
  const navigate = useNavigate();
  
  const handleAPIError = (error) => {
    // Network errors
    if (!error.response) {
      showNotification({
        type: 'error',
        message: 'Network error. Please check your connection.',
        action: { label: 'Retry', callback: () => window.location.reload() }
      });
      return;
    }
    
    // HTTP errors
    switch (error.response.status) {
      case 401:
        // Redirect to login
        navigate('/login');
        break;
        
      case 403:
        showNotification({
          type: 'error',
          message: 'You don\'t have permission to perform this action.'
        });
        break;
        
      case 404:
        showNotification({
          type: 'error',
          message: 'The requested resource was not found.'
        });
        break;
        
      case 422:
        // Validation errors - return for form handling
        return error.response.data.errors;
        
      case 500:
        showNotification({
          type: 'error',
          message: 'Server error. Our team has been notified.',
          duration: 10000
        });
        break;
        
      default:
        showNotification({
          type: 'error',
          message: error.response.data.message || 'An unexpected error occurred.'
        });
    }
  };
  
  return { handleAPIError };
};
```

### Caching Strategy
```javascript
// React Query integration for data caching
const useFeatureData = (params) => {
  return useQuery({
    queryKey: ['feature-data', params],
    queryFn: () => FeatureAPI.getFeatureData(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    refetchOnWindowFocus: false,
    retry: (failureCount, error) => {
      // Don't retry on 4xx errors
      if (error.response?.status >= 400 && error.response?.status < 500) {
        return false;
      }
      return failureCount < 3;
    }
  });
};

// Mutation with optimistic updates
const useUpdateFeatureItem = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, updates }) => FeatureAPI.updateFeatureItem(id, updates),
    onMutate: async ({ id, updates }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries(['feature-data']);
      
      // Snapshot previous value
      const previousData = queryClient.getQueryData(['feature-data']);
      
      // Optimistically update
      queryClient.setQueryData(['feature-data'], (old) => ({
        ...old,
        items: old.items.map(item => 
          item.id === id ? { ...item, ...updates } : item
        )
      }));
      
      return { previousData };
    },
    onError: (err, variables, context) => {
      // Rollback on error
      queryClient.setQueryData(['feature-data'], context.previousData);
    },
    onSettled: () => {
      // Refetch to ensure consistency
      queryClient.invalidateQueries(['feature-data']);
    }
  });
};
```

## ðŸŽ¨ Component Styling Architecture

### Styled Components Strategy
```javascript
// Theme-based styled components
const FeatureContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.lg};
  padding: ${({ theme }) => theme.spacing.lg};
  background-color: ${({ theme }) => theme.colors.background.primary};
  border-radius: ${({ theme }) => theme.borderRadius.md};
  
  @media ${({ theme }) => theme.breakpoints.mobile} {
    padding: ${({ theme }) => theme.spacing.md};
    gap: ${({ theme }) => theme.spacing.md};
  }
`;

const FeatureHeader = styled.header`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border.light};
`;

const FeatureContent = styled.main`
  flex: 1;
  display: grid;
  grid-template-columns: ${({ variant }) => {
    switch (variant) {
      case 'sidebar': return '300px 1fr';
      case 'split': return '1fr 1fr';
      default: return '1fr';
    }
  }};
  gap: ${({ theme }) => theme.spacing.lg};
  
  @media ${({ theme }) => theme.breakpoints.tablet} {
    grid-template-columns: 1fr;
  }
`;
```

### CSS-in-JS Component Patterns
```javascript
// Consistent styling patterns for components
const componentStyles = {
  card: {
    backgroundColor: 'background.secondary',
    borderRadius: 'md',
    padding: 'lg',
    boxShadow: 'sm',
    border: '1px solid',
    borderColor: 'border.light'
  },
  
  button: {
    primary: {
      backgroundColor: 'primary.main',
      color: 'primary.contrastText',
      fontWeight: 'semibold',
      padding: 'sm lg',
      borderRadius: 'md',
      transition: 'all 0.2s ease'
    },
    secondary: {
      backgroundColor: 'transparent',
      color: 'text.primary',
      border: '1px solid',
      borderColor: 'border.medium',
      padding: 'sm lg',
      borderRadius: 'md'
    }
  },
  
  input: {
    backgroundColor: 'background.primary',
    border: '1px solid',
    borderColor: 'border.medium',
    borderRadius: 'sm',
    padding: 'sm',
    fontSize: 'body',
    '&:focus': {
      borderColor: 'primary.main',
      outline: 'none',
      boxShadow: '0 0 0 2px rgba(primary.main, 0.2)'
    }
  }
};
```

## ðŸ“± Responsive Component Architecture

### Breakpoint Management
```javascript
// Responsive component behavior
const useResponsiveLayout = () => {
  const [breakpoint, setBreakpoint] = useState('desktop');
  
  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth;
      if (width < 768) setBreakpoint('mobile');
      else if (width < 1024) setBreakpoint('tablet');
      else setBreakpoint('desktop');
    };
    
    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return breakpoint;
};

// Responsive component rendering
const ResponsiveFeatureLayout = ({ children }) => {
  const breakpoint = useResponsiveLayout();
  
  switch (breakpoint) {
    case 'mobile':
      return <MobileLayout>{children}</MobileLayout>;
    case 'tablet':
      return <TabletLayout>{children}</TabletLayout>;
    default:
      return <DesktopLayout>{children}</DesktopLayout>;
  }
};
```

### Mobile-First Component Design
```css
/* Mobile-first CSS approach */
.feature-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1rem;
  
  /* Tablet */
  @media (min-width: 768px) {
    grid-template-columns: repeat(2, 1fr);
    gap: 1.5rem;
  }
  
  /* Desktop */
  @media (min-width: 1024px) {
    grid-template-columns: repeat(3, 1fr);
    gap: 2rem;
  }
  
  /* Large desktop */
  @media (min-width: 1200px) {
    grid-template-columns: repeat(4, 1fr);
  }
}
```

## â™¿ Accessibility Integration

### Accessible Component Patterns
```javascript
// Screen reader friendly components
const AccessibleFeatureCard = ({ data, onAction }) => {
  const cardId = `feature-card-${data.id}`;
  const titleId = `feature-title-${data.id}`;
  
  return (
    <div
      role="article"
      aria-labelledby={titleId}
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          onAction(data);
        }
      }}
    >
      <h3 id={titleId}>{data.title}</h3>
      <p aria-describedby={cardId}>{data.description}</p>
      <button
        aria-label={`Action for ${data.title}`}
        onClick={() => onAction(data)}
      >
        Take Action
      </button>
    </div>
  );
};

// Focus management
const useFocusManagement = () => {
  const focusRef = useRef();
  
  const setFocus = (element) => {
    if (element) {
      element.focus();
    } else if (focusRef.current) {
      focusRef.current.focus();
    }
  };
  
  return { focusRef, setFocus };
};
```

### Keyboard Navigation
```javascript
// Keyboard navigation for component interactions
const useKeyboardNavigation = (items, onSelect) => {
  const [focusedIndex, setFocusedIndex] = useState(0);
  
  const handleKeyDown = (e) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setFocusedIndex((prev) => Math.min(prev + 1, items.length - 1));
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        setFocusedIndex((prev) => Math.max(prev - 1, 0));
        break;
        
      case 'Enter':
      case ' ':
        e.preventDefault();
        onSelect(items[focusedIndex]);
        break;
        
      case 'Escape':
        setFocusedIndex(0);
        break;
    }
  };
  
  return { focusedIndex, handleKeyDown };
};
```

## ðŸ§ª Component Testing Architecture

### Component Testing Strategy
```javascript
// Comprehensive component testing
describe('FeatureComponent Integration', () => {
  const mockAPIClient = {
    get: jest.fn(),
    post: jest.fn(),
    put: jest.fn(),
    delete: jest.fn()
  };
  
  const renderWithProviders = (component, initialState = {}) => {
    return render(
      <ThemeProvider theme={testTheme}>
        <FeatureProvider apiClient={mockAPIClient} initialState={initialState}>
          {component}
        </FeatureProvider>
      </ThemeProvider>
    );
  };
  
  describe('Component Rendering', () => {
    it('renders feature component with data', async () => {
      mockAPIClient.get.mockResolvedValue({ data: mockFeatureData });
      
      renderWithProviders(<FeatureComponent />);
      
      expect(screen.getByRole('main')).toBeInTheDocument();
      expect(screen.getByText(mockFeatureData.title)).toBeInTheDocument();
    });
    
    it('handles loading state correctly', () => {
      renderWithProviders(<FeatureComponent />, { loading: true });
      
      expect(screen.getByRole('progressbar')).toBeInTheDocument();
      expect(screen.getByText('Loading...')).toBeInTheDocument();
    });
    
    it('handles error state correctly', () => {
      const errorMessage = 'Failed to load data';
      renderWithProviders(<FeatureComponent />, { error: errorMessage });
      
      expect(screen.getByRole('alert')).toBeInTheDocument();
      expect(screen.getByText(errorMessage)).toBeInTheDocument();
    });
  });
  
  describe('User Interactions', () => {
    it('handles user actions correctly', async () => {
      const mockOnAction = jest.fn();
      mockAPIClient.get.mockResolvedValue({ data: mockFeatureData });
      
      renderWithProviders(
        <FeatureComponent onAction={mockOnAction} />
      );
      
      const actionButton = screen.getByRole('button', { name: /action/i });
      fireEvent.click(actionButton);
      
      expect(mockOnAction).toHaveBeenCalledWith(expectedActionData);
    });
    
    it('handles keyboard navigation', () => {
      renderWithProviders(<FeatureComponent />);
      
      const component = screen.getByRole('main');
      fireEvent.keyDown(component, { key: 'ArrowDown' });
      
      expect(screen.getByRole('button')).toHaveFocus();
    });
  });
  
  describe('API Integration', () => {
    it('fetches data on mount', async () => {
      renderWithProviders(<FeatureComponent />);
      
      await waitFor(() => {
        expect(mockAPIClient.get).toHaveBeenCalledWith('/api/v1/feature/data');
      });
    });
    
    it('handles API errors gracefully', async () => {
      mockAPIClient.get.mockRejectedValue(new Error('API Error'));
      
      renderWithProviders(<FeatureComponent />);
      
      await waitFor(() => {
        expect(screen.getByRole('alert')).toBeInTheDocument();
      });
    });
  });
});
```

### Integration Testing
```javascript
// Testing component integration with BFF
describe('BFF Integration Tests', () => {
  it('integrates with BFF endpoints correctly', async () => {
    const server = setupMockServer();
    
    server.use(
      rest.get('/api/v1/feature/data', (req, res, ctx) => {
        return res(ctx.json(mockBFFResponse));
      })
    );
    
    renderWithProviders(<FeatureComponent />);
    
    await waitFor(() => {
      expect(screen.getByText(mockBFFResponse.data.title)).toBeInTheDocument();
    });
  });
  
  it('handles BFF authentication correctly', async () => {
    const server = setupMockServer();
    
    server.use(
      rest.get('/api/v1/feature/data', (req, res, ctx) => {
        const authHeader = req.headers.get('Authorization');
        if (!authHeader) {
          return res(ctx.status(401), ctx.json({ error: 'Unauthorized' }));
        }
        return res(ctx.json(mockBFFResponse));
      })
    );
    
    renderWithProviders(<FeatureComponent />);
    
    // Should trigger auth flow
    await waitFor(() => {
      expect(mockAuthRedirect).toHaveBeenCalled();
    });
  });
});
```

## âœ… Architecture Validation Checklist

### Component Design Validation
- [ ] **Component boundaries are clear and logical**
- [ ] **Props interfaces are well-defined and typed**
- [ ] **Component hierarchy supports reusability**
- [ ] **State management is appropriate for complexity**
- [ ] **Responsive design is built into component structure**

### Integration Validation
- [ ] **BFF integration patterns are consistent**
- [ ] **Data flow is efficient and predictable**
- [ ] **Error handling is comprehensive**
- [ ] **Caching strategy supports performance goals**
- [ ] **Authentication integration is secure**

### Performance Validation
- [ ] **Component rendering is optimized**
- [ ] **Bundle splitting supports lazy loading**
- [ ] **API calls are efficiently batched**
- [ ] **Memory leaks are prevented**
- [ ] **Performance monitoring is integrated**

### Accessibility Validation
- [ ] **Screen reader support is comprehensive**
- [ ] **Keyboard navigation works throughout**
- [ ] **Focus management is proper**
- [ ] **Color contrast meets WCAG standards**
- [ ] **ARIA labels are correctly implemented**

## ðŸ”— Next Phase Preparation

### For Atomic Implementation Tasks
- **Component Implementation Guidance:** [Specific implementation requirements for each component]
- **Integration Task Breakdown:** [Detailed tasks for BFF integration and testing]
- **Testing Task Specifications:** [Comprehensive testing requirements per component]
- **Performance Task Definition:** [Specific performance optimization tasks]

### Implementation Readiness Assessment
- **All component interfaces are defined**
- **BFF integration patterns are established**
- **State management architecture is complete**
- **Testing strategy covers all integration points**
- **Performance requirements are measurable**
```

## Memory Actions During Process

### Initial Context Retrieval
```
memory_search "design-analysis frontend-tech-planning [feature-name]" repository="[project-repo]"
memory_store_chunk
  content="Starting component architecture for [feature-name]. Design context: [design summary]. Technical context: [tech summary]"
  tags=["component-architecture", "started", "feature-name", "integration-design"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### After Architecture Design
```
memory_store_decision
  decision="Component architecture and integration design for [feature-name]"
  rationale="Component hierarchy: [hierarchy]. Integration patterns: [patterns]. State management: [approach]. Performance strategy: [performance]"
  context="Components: [count]. BFF endpoints: [list]. State boundaries: [definition]. Testing strategy: [approach]"
  session_id="[current-session]"
  repository="[project-repo]"
```

### After Optional User Review
```
memory_store_chunk
  content="User architectural feedback for [feature-name]: [feedback summary]. Adjustments made: [changes]"
  tags=["component-architecture", "user-feedback", "architectural-decisions"]
  session_id="[current-session]"
  repository="[project-repo]"
```

### After Architecture Completion
```
memory_create_thread
  name="Frontend Component Development: [feature-name]"
  description="Complete frontend development from design through component architecture to implementation"
  chunk_ids=["[design-analysis-chunks]", "[tech-planning-chunks]", "[component-architecture-chunks]"]
  repository="[project-repo]"
```

## Quality Validation

Before finalizing component architecture, ensure:

### Architecture Quality
- [ ] **Component boundaries follow single responsibility principle**
- [ ] **Data flow is unidirectional and predictable**
- [ ] **State management complexity matches feature requirements**
- [ ] **Component reusability is maximized**

### Integration Quality  
- [ ] **BFF integration follows established patterns**
- [ ] **Error handling covers all failure scenarios**
- [ ] **Performance optimization is built into architecture**
- [ ] **Testing strategy covers all integration points**

### Implementation Readiness
- [ ] **All component interfaces are fully specified**
- [ ] **Development workflow is clear and actionable**
- [ ] **Testing requirements are comprehensive**
- [ ] **Performance targets are measurable**

## Final Instructions

1. **Design Fidelity** - Ensure component architecture directly implements design specifications
2. **Integration First** - Design all components with BFF integration as primary concern  
3. **Performance Aware** - Build performance optimization into component architecture
4. **Accessibility Compliant** - Ensure accessibility is architectural, not afterthought
5. **Testing Comprehensive** - Plan testing strategy that covers all component interactions
6. **Reusability Focus** - Design components for maximum reuse across features
7. **Memory Integration** - Store all architectural decisions and patterns for future reference

This component architecture provides the detailed foundation for atomic task implementation with optimal user experience, system integration, and code quality.