## ðŸ§  Enhanced Reasoning Instructions

**IMPORTANT**: Use both Memory MCP and Sequential Thinking MCP for enhanced analysis:

### Memory MCP Integration
- Store findings, decisions, and patterns in memory for cross-session learning
- Reference previous analysis and build upon established knowledge
- Tag entries appropriately for organization and retrieval

### Sequential Thinking MCP Usage  
- Use `mcp__sequential-thinking__sequentialthinking` for complex analysis and reasoning
- Break down complex problems into systematic thinking steps
- Allow thoughts to evolve and build upon previous insights
- Question assumptions and explore alternative approaches
- Generate and verify solution hypotheses through structured reasoning

### ðŸ§  Zen MCP Integration (CRITICAL FOR SECURITY ANALYSIS)
**Use Zen tools for comprehensive security assessment:**
- **`mcp__zen__codereview`** - Deep security-focused code review
  ```bash
  mcp__zen__codereview
    files=["src/auth/", "src/api/", "src/db/", "src/crypto/"]
    prompt="Perform security-focused code review identifying vulnerabilities, insecure patterns, and OWASP Top 10 issues"
    model="pro"
    review_type="security"
    severity_filter="all"
  ```
- **`mcp__zen__thinkdeep`** - Explore attack vectors and exploit scenarios
  ```bash
  mcp__zen__thinkdeep
    prompt="Analyze potential attack vectors and security implications for identified vulnerabilities"
    model="pro"
    thinking_mode="high"
    focus_areas=["authentication", "authorization", "injection", "data_exposure"]
  ```
- **`mcp__zen__debug`** - Root cause analysis for security issues
- **Benefits**: Comprehensive vulnerability identification, severity assessment, exploit analysis

### ðŸš€ Task Tool Usage (ESSENTIAL FOR VULNERABILITY DISCOVERY)
**Use Task tool for systematic security scanning:**
```bash
Task(
  description="Security vulnerability scan",
  prompt="Search for security vulnerabilities including:
    1. Authentication and authorization flaws (missing checks, weak tokens)
    2. Injection vulnerabilities (SQL, NoSQL, command, LDAP)
    3. Sensitive data exposure (hardcoded secrets, logging PII)
    4. Insecure cryptography (weak algorithms, poor key management)
    5. Input validation issues (XSS, path traversal)
    6. Insecure dependencies and configurations
    7. Session management flaws
    8. CORS and security header misconfigurations"
)
```
**Benefits**: Comprehensive vulnerability coverage, pattern-based detection, efficient scanning

This multi-tool approach enables thorough security analysis and vulnerability discovery.

---

You are a security researcher specializing in application security and vulnerability assessment. Your goal is to discover and document ACTUAL security vulnerabilities through systematic code exploration.

## ðŸš¨ CRITICAL: Discovery-First Security Analysis

**MANDATORY PROCESS:**
1. **VERIFY** components and APIs from prompts #1-6
2. **DISCOVER** actual security vulnerabilities in real code
3. **VALIDATE** every vulnerability with file:line evidence
4. **ASSESS** actual risk based on code patterns found
5. **NEVER** create hypothetical vulnerabilities or example attacks

## ðŸ”— Prompt Chaining Rules

**CRITICAL: This is prompt #7 in the analysis chain.**

**Input Validation:**
- **REQUIRED**: First read ALL outputs from prompts #1-6 if they exist
- **VERIFY**: Components and endpoints from previous analyses still exist
- **USE**: Only verified code locations for security scanning
- **FOCUS**: On actual vulnerabilities found in real files
- **REJECT**: Any example vulnerabilities not found in code

**Evidence Requirements:**
- Every vulnerability MUST have file:line reference
- Every security issue MUST show actual vulnerable code
- Every risk assessment MUST cite real patterns
- Every remediation MUST address a found vulnerability
- NO example CVEs without actual package.json evidence

**Chain Foundation:**
- Store only verified vulnerabilities with tags: `["security", "vulnerabilities", "verified", "prompt-7"]`
- Document actual security issues for compliance tracking
- Include exact vulnerable code locations for fixing

## File Organization

**REQUIRED OUTPUT LOCATIONS:**

- `docs/code-review/6-SECURITY_ANALYSIS.md` - Complete security assessment with remediation plan
- `scripts/security-monitor.js` - Automated security monitoring script

**IMPORTANT RULES:**

- Focus on critical vulnerabilities first (CVSS 7.0+)
- Identify authentication and authorization flaws
- Check for injection vulnerabilities and cryptographic issues
- Provide practical remediation with code examples

## 0. Session Initialization

```
memory_tasks session_create session_id="security-$(date +%s)" repository="github.com/org/repo"
memory_get_context repository="github.com/org/repo"
memory_read operation="search" options='{"query":"security vulnerabilities authentication","repository":"github.com/org/repo"}'
```

## 1. Validate Previous Findings First

### Step 1: Load and Verify Components from Prior Analysis

```bash
# FIRST: Verify previous analyses exist and are valid
echo "=== Loading verified components from previous prompts ==="

# Check for required previous analyses
for i in {1..6}; do
  if [ -f "docs/code-review/${i}-*.md" ]; then
    echo "âœ“ Found analysis from prompt #$i"
  else
    echo "âœ— MISSING: Analysis from prompt #$i - security analysis may be incomplete"
  fi
done

# Extract verified API endpoints for attack surface mapping
echo "=== API endpoints to analyze for security ==="
if [ -f "docs/code-review/3-API_CONTRACT_ANALYSIS.md" ]; then
  grep -E "Endpoint:.*\[|Method|File:" docs/code-review/3-API_CONTRACT_ANALYSIS.md
fi

# Get verified components for focused security scanning
echo "=== Components to scan for vulnerabilities ==="
if [ -f "docs/code-review/2-ARCHITECTURE_ANALYSIS.md" ]; then
  grep -E "âœ“ COMPONENT:|Path:|Evidence:" docs/code-review/2-ARCHITECTURE_ANALYSIS.md
fi
```

## 2. Discover Actual Security Vulnerabilities

### Step 2: Find Real Authentication Issues with Evidence

```bash
echo "=== Searching for actual authentication vulnerabilities ==="

# First, find actual authentication code files
AUTH_FILES=$(find . -name "*.js" -o -name "*.ts" | xargs grep -l "auth\|login\|jwt\|token" 2>/dev/null | grep -v node_modules | head -20)

# Check for hardcoded secrets in real files
echo "--- Hardcoded Credentials Check ---"
for file in $AUTH_FILES; do
  if [ -f "$file" ]; then
    # Look for actual hardcoded values
    grep -n "password.*=.*[\"'][^\"']*[\"']\|secret.*=.*[\"'][^\"']*[\"']\|key.*=.*[\"'][^\"']*[\"']" "$file" 2>/dev/null | \
      grep -v "process.env\|env\.\|config\." | head -5
  fi
done

# Find weak session management patterns
echo "--- Session Security Issues ---"
for file in $AUTH_FILES; do
  if [ -f "$file" ]; then
    # Check for predictable session generation
    grep -n "Math\.random\|Date\.now\|timestamp" "$file" 2>/dev/null | \
      grep -E "session|token|id" | head -5
  fi
done
```

### Step 3: Find Real Injection Vulnerabilities

```bash
echo "=== Searching for actual injection vulnerabilities ==="

# Get actual source files to scan
SOURCE_FILES=$(find . -name "*.js" -o -name "*.ts" -o -name "*.go" -o -name "*.py" | grep -v node_modules | head -50)

# SQL Injection - Look for actual string concatenation in queries
echo "--- SQL Injection Patterns ---"
for file in $SOURCE_FILES; do
  if [ -f "$file" ]; then
    # Find actual query building with concatenation
    SQL_CONCAT=$(grep -n "query.*+\|WHERE.*\${.*}\|SELECT.*+" "$file" 2>/dev/null)
    if [ -n "$SQL_CONCAT" ]; then
      echo "FOUND in $file:"
      echo "$SQL_CONCAT" | head -3
    fi
  fi
done

# Command Injection - Find actual exec calls
echo "--- Command Injection Risks ---"
for file in $SOURCE_FILES; do
  if [ -f "$file" ]; then
    # Look for exec/spawn with user input
    CMD_INJECTION=$(grep -n "exec\|spawn\|system" "$file" 2>/dev/null | grep -v "^[[:space:]]*//\|^[[:space:]]*\*")
    if [ -n "$CMD_INJECTION" ]; then
      echo "FOUND in $file:"
      echo "$CMD_INJECTION" | head -3
      # Check if user input flows to these commands
      grep -n -B5 -A5 "exec\|spawn" "$file" 2>/dev/null | grep -E "req\.|params\.|body\.|query\." | head -3
    fi
  fi
done

# XSS - Find actual unsafe DOM manipulation
echo "--- XSS Vulnerabilities ---"
UI_FILES=$(find . -name "*.jsx" -o -name "*.tsx" -o -name "*.js" | grep -v node_modules | head -30)
for file in $UI_FILES; do
  if [ -f "$file" ]; then
    XSS_PATTERNS=$(grep -n "innerHTML\|dangerouslySetInnerHTML\|document\.write" "$file" 2>/dev/null)
    if [ -n "$XSS_PATTERNS" ]; then
      echo "FOUND in $file:"
      echo "$XSS_PATTERNS"
    fi
  fi
done
```

### Step 4: Find Real Cryptographic Issues

```bash
echo "=== Searching for cryptographic vulnerabilities ==="

# Weak algorithms in actual use
echo "--- Weak Cryptographic Algorithms ---"
for file in $SOURCE_FILES; do
  if [ -f "$file" ]; then
    WEAK_CRYPTO=$(grep -n "createHash.*['\"]md5\|createHash.*['\"]sha1" "$file" 2>/dev/null)
    if [ -n "$WEAK_CRYPTO" ]; then
      echo "WEAK ALGORITHM in $file:"
      echo "$WEAK_CRYPTO"
    fi
  fi
done

# Predictable randomness for security features
echo "--- Insufficient Randomness ---"
for file in $SOURCE_FILES; do
  if [ -f "$file" ]; then
    # Check if Math.random is used for security
    BAD_RANDOM=$(grep -n "Math\.random" "$file" 2>/dev/null | grep -E "token|session|password|key|salt")
    if [ -n "$BAD_RANDOM" ]; then
      echo "INSECURE RANDOM in $file:"
      echo "$BAD_RANDOM"
    fi
  fi
done
```

## 3. Analyze Configuration Security

### Step 5: Find Real Configuration Issues

```bash
echo "=== Checking configuration security ==="

# First check if .env files are properly gitignored
echo "--- Checking for exposed environment files ---"
if [ -f ".gitignore" ]; then
  grep -q "\.env" .gitignore || echo "âš ï¸  WARNING: .env not in .gitignore"
fi

# Find actual exposed secrets
echo "--- Exposed Secrets in Tracked Files ---"
git ls-files 2>/dev/null | while read file; do
  if [ -f "$file" ]; then
    SECRETS=$(grep -n "api[_-]key.*=.*[\"'][^\"']*[\"']\|password.*=.*[\"'][^\"']*[\"']" "$file" 2>/dev/null | \
              grep -v "process\.env\|ENV\|example\|placeholder")
    if [ -n "$SECRETS" ]; then
      echo "EXPOSED SECRET in $file:"
      echo "$SECRETS"
    fi
  fi
done

# Check actual debug settings
echo "--- Debug Mode in Production ---"
CONFIG_FILES=$(find . -name "*.config.*" -o -name "*.env*" | grep -v node_modules | head -20)
for file in $CONFIG_FILES; do
  if [ -f "$file" ]; then
    DEBUG_ENABLED=$(grep -n "debug.*true\|DEBUG.*true\|NODE_ENV.*development" "$file" 2>/dev/null)
    if [ -n "$DEBUG_ENABLED" ]; then
      echo "DEBUG ENABLED in $file:"
      echo "$DEBUG_ENABLED"
    fi
  fi
done

# Check for actual security header implementation
echo "--- Security Headers Check ---"
EXPRESS_FILES=$(find . -name "*.js" -o -name "*.ts" | xargs grep -l "express\|app\." 2>/dev/null | grep -v node_modules | head -10)
HEADERS_MISSING=0
for file in $EXPRESS_FILES; do
  if [ -f "$file" ]; then
    # Check if security headers are set
    HAS_HELMET=$(grep -n "helmet\|security.*header" "$file" 2>/dev/null)
    if [ -z "$HAS_HELMET" ]; then
      HAS_APP=$(grep -n "app\.\|express()" "$file" 2>/dev/null | head -1)
      if [ -n "$HAS_APP" ]; then
        echo "âŒ NO SECURITY HEADERS in Express app: $file:$(echo "$HAS_APP" | cut -d: -f2)"
        ((HEADERS_MISSING++))
      fi
    else
      echo "âœ“ Security headers found in $file"
    fi
  fi
done
echo "Total Express apps without security headers: $HEADERS_MISSING"
```

## 4. Generate Evidence-Based Security Report

### CRITICAL: Document Only Discovered Vulnerabilities

Create `docs/code-review/7-SECURITY_ANALYSIS.md` with ONLY verified findings:

````markdown
# Security Analysis - VERIFIED FINDINGS ONLY

## Discovery Summary

**Analysis Date**: [Current date]
**Files Scanned**: [Actual count from SOURCE_FILES]
**Authentication Files**: [Count from AUTH_FILES]
**Vulnerabilities Found**: [Actual count with evidence]

## Executive Summary

**IMPORTANT**: Risk level based on actual findings only.

**Risk Level**: [Based on actual vulnerabilities found]
**Critical Issues Found**: [Count of actual critical vulnerabilities]
**Total Security Issues**: [Count of all verified issues]

## Verified Vulnerabilities

### Critical Security Issues

[Only document if found in Steps 2-5]

#### VULN-001: [Actual Vulnerability Type]
- **File**: `[actual-file.js:line]`
- **Evidence**:
  ```javascript
  // [Actual vulnerable code from discovery]
  ```
- **Risk**: [Explain actual risk based on code]
- **CVSS**: [Calculate based on actual vulnerability]

### Authentication & Authorization Issues

[Only document if found in Step 2]

#### Hardcoded Credentials
**Files with hardcoded secrets**:
[List actual files:lines found in scan]

#### Weak Session Management
**Files using predictable randomness**:
[List actual files:lines where Math.random used for tokens]

### Injection Vulnerabilities

[Only document if found in Step 3]

#### SQL Injection Risks
**Query concatenation found in**:
[List actual files:lines with evidence]

#### Command Injection Risks
**Unsafe exec/spawn usage**:
[List actual files:lines]

### Cryptographic Issues

[Only document if found in Step 4]

#### Weak Algorithms
**MD5/SHA1 usage found**:
[List actual files:lines]

### Configuration Security

[Only document if found in Step 5]

#### Exposed Secrets
**Secrets in tracked files**:
[List actual findings]

#### Missing Security Headers
**Express apps without security headers**:
[List actual files]

## NOT FOUND (Security Elements Checked But Missing)

### Expected But Not Found
- âŒ Rate limiting middleware: NOT FOUND
- âŒ CSRF protection: NOT FOUND
- âŒ Input validation middleware: NOT FOUND
- âŒ Security headers (helmet.js): NOT FOUND in [X] Express apps
- âŒ Secure session configuration: NOT FOUND

## Attack Surface Analysis (From Actual Endpoints)

[Only include if API endpoints were found in prompt #3]

### Verified Entry Points
| Endpoint | File | Auth Status | Security Issue |
|----------|------|-------------|----------------|
| [Actual endpoint] | [file:line] | [Found/Not Found] | [Actual issue] |

## Remediation for Discovered Issues

[Only provide fixes for actual vulnerabilities found]

### Fix: [Actual Vulnerability]
**Current vulnerable code** at `[file:line]`:
```javascript
[Actual code]
```

**Secure implementation**:
```javascript
[Fixed code]
```
````

## 5. Check Dependency Vulnerabilities

### Step 6: Analyze Actual Package Vulnerabilities

```bash
echo "=== Checking for dependency vulnerabilities ==="

# Check if package.json exists
if [ -f "package.json" ]; then
  echo "--- NPM Audit Analysis ---"
  # Run actual npm audit
  npm audit --json > temp-audit.json 2>/dev/null || true
  
  if [ -f "temp-audit.json" ]; then
    # Extract actual vulnerabilities
    VULN_COUNT=$(jq '.vulnerabilities | length' temp-audit.json 2>/dev/null || echo "0")
    if [ "$VULN_COUNT" -gt "0" ]; then
      echo "FOUND $VULN_COUNT vulnerable packages:"
      jq -r '.vulnerabilities | to_entries[] | "\(.key) - Severity: \(.value.severity)"' temp-audit.json 2>/dev/null | head -10
    fi
    rm -f temp-audit.json
  fi
elif [ -f "go.mod" ]; then
  echo "--- Go Module Vulnerability Check ---"
  govulncheck ./... 2>/dev/null || echo "govulncheck not installed"
elif [ -f "requirements.txt" ]; then
  echo "--- Python Package Safety Check ---"
  safety check 2>/dev/null || echo "safety not installed"
fi
```

### Step 7: Find Missing Security Controls

```bash
echo "=== Checking for missing security controls ==="

# Check for rate limiting implementation
echo "--- Rate Limiting Check ---"
RATE_LIMIT=$(grep -rn "rate.*limit\|rateLimit\|express-rate-limit" . --include="*.js" --include="*.ts" 2>/dev/null | grep -v node_modules)
if [ -z "$RATE_LIMIT" ]; then
  echo "âŒ NO RATE LIMITING FOUND"
else
  echo "âœ“ Rate limiting found:"
  echo "$RATE_LIMIT" | head -3
fi

# Check for CSRF protection
echo "--- CSRF Protection Check ---"
CSRF=$(grep -rn "csrf\|csurf" . --include="*.js" --include="*.ts" 2>/dev/null | grep -v node_modules)
if [ -z "$CSRF" ]; then
  echo "âŒ NO CSRF PROTECTION FOUND"
else
  echo "âœ“ CSRF protection found:"
  echo "$CSRF" | head -3
fi

# Check for input validation
echo "--- Input Validation Check ---"
VALIDATION=$(grep -rn "joi\|yup\|express-validator\|zod" . --include="*.js" --include="*.ts" 2>/dev/null | grep -v node_modules)
if [ -z "$VALIDATION" ]; then
  echo "âŒ NO INPUT VALIDATION LIBRARY FOUND"
else
  echo "âœ“ Input validation found:"
  echo "$VALIDATION" | head -3
fi
```

## 6. Validation Before Documentation

### Verify All Security Findings

```bash
echo "=== Validating security findings ===="

# Count actual vulnerabilities found
HARDCODED_COUNT=$(grep -c "FOUND in" security-scan.log 2>/dev/null || echo "0")
SQL_INJECTION_COUNT=$(grep -c "SQL.*FOUND" security-scan.log 2>/dev/null || echo "0")
XSS_COUNT=$(grep -c "XSS.*FOUND" security-scan.log 2>/dev/null || echo "0")

echo "Documented vulnerabilities:"
echo "- Hardcoded secrets: $HARDCODED_COUNT"
echo "- SQL injection risks: $SQL_INJECTION_COUNT"
echo "- XSS vulnerabilities: $XSS_COUNT"

# Ensure all findings have file:line references
echo "=== Checking evidence quality ===="
EVIDENCE_COUNT=$(grep -c ":[0-9]" security-scan.log 2>/dev/null || echo "0")
echo "Findings with file:line evidence: $EVIDENCE_COUNT"
```

### Documentation Checklist

Before saving the security analysis:
- [ ] Every vulnerability has file:line evidence
- [ ] Every security issue shows actual code
- [ ] All remediations address found problems
- [ ] No example vulnerabilities included
- [ ] Missing security controls documented
- [ ] "NOT FOUND" section lists expected but missing items

## 7. Create Security Monitoring Script

### Only If Vulnerabilities Were Found

```bash
# Only create monitoring script if vulnerabilities discovered
if [ "$HARDCODED_COUNT" -gt 0 ] || [ "$SQL_INJECTION_COUNT" -gt 0 ] || [ "$XSS_COUNT" -gt 0 ]; then
  cat > scripts/security-monitor.js << 'EOF'
#!/usr/bin/env node

// Security monitoring for discovered vulnerabilities
const vulnerabilities = {
  hardcodedSecrets: [/* List actual files with hardcoded secrets */],
  sqlInjection: [/* List actual files with SQL concatenation */],
  xssRisks: [/* List actual files with innerHTML usage */],
  missingControls: {
    rateLimiting: /* true/false based on discovery */,
    csrf: /* true/false based on discovery */,
    inputValidation: /* true/false based on discovery */
  }
};

// Monitor only actual vulnerabilities found during analysis
console.log('Monitoring vulnerabilities:', vulnerabilities);

// Add specific checks based on what was actually found
EOF
fi
```

```

memory_store_chunk
content="Security analysis completed. Vulnerabilities found: [actual count]. Missing controls: [list]. All findings verified with file:line evidence."
session_id="security-$(date +%s)"
repository="github.com/org/repo"
tags=["security", "vulnerabilities", "verified", "evidence-based"]

memory_store_decision
decision="Security implementation status: [needs-improvement|partially-secure|secure]"
rationale="Found [X] actual vulnerabilities with evidence, [Y] missing security controls. Focus areas: [specific findings]"
context="Discovery-based analysis found: [summary of actual findings]"
session_id="security-$(date +%s)"
repository="github.com/org/repo"

memory_tasks session_end session_id="security-$(date +%s)" repository="github.com/org/repo"

```

## Execution Notes

- **Discovery First**: Find actual vulnerabilities before documenting
- **Evidence Required**: Every finding must have file:line reference
- **No Examples**: Document only real vulnerabilities found in code
- **Missing Controls**: Clearly document expected but missing security features
- **Language Agnostic**: Adapts search patterns to any technology stack

## ðŸ“‹ Todo List Generation

**REQUIRED**: Generate or append to `docs/code-review/code-review-todo-list.md` with findings from this analysis.

### Todo Entry Format - EVIDENCE-BASED ONLY
```markdown
## Security Vulnerability Analysis Findings

**Analysis Date**: [Date]
**Files Scanned**: [Count]
**Vulnerabilities Found**: [Count with evidence]
**Missing Controls**: [Count]

### ðŸ”´ CRITICAL (Immediate Action Required)
[Only if critical vulnerabilities found with evidence]
- [ ] **Fix [Vulnerability Type] in [Component]**: Found at `[file:line]`
  - **Evidence**: [Actual vulnerable code found]
  - **Risk**: [Actual risk based on code]
  - **Effort**: [Time to fix]
  - **CVSS**: [Score if applicable]

### ðŸŸ¡ HIGH (Sprint Priority)
[Only for verified security issues]
- [ ] **Remove hardcoded [secret type]**: Found at `[file:line]`
  - **Evidence**: [Actual hardcoded value pattern]
  - **Risk**: [Exposure risk]
  - **Fix**: Move to environment variable

### ðŸŸ¢ MEDIUM (Backlog)
[Only for actual findings]
- [ ] **Implement [missing control]**: Not found in codebase
  - **Searched**: [Where you looked]
  - **Risk**: [What attacks this enables]
  - **Solution**: [Specific implementation]

### ðŸ”µ LOW (Future Consideration)
[Minor issues with evidence]

### âŒ MISSING SECURITY CONTROLS
- [ ] **No rate limiting found**
  - **Searched**: All API endpoints in [files]
  - **Risk**: DoS and brute force attacks
  - **Recommendation**: Implement express-rate-limit
- [ ] **No CSRF protection found**
  - **Searched**: Form handlers and state-changing endpoints
  - **Risk**: Cross-site request forgery
- [ ] **No input validation library**
  - **Searched**: API route handlers
  - **Risk**: Injection attacks and data integrity
```

### Implementation Rules
1. ONLY create todos for vulnerabilities found in actual code
2. EVERY vulnerability must have file:line evidence
3. EVERY missing control must document where it was searched for
4. NO hypothetical vulnerabilities or example CVEs
5. Include "MISSING" section for expected security features
6. Tag with `#security #verified` and specific vulnerability types