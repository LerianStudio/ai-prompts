## üß† Enhanced Reasoning Instructions

**IMPORTANT**: Use both Memory MCP and Sequential Thinking MCP for enhanced analysis:

### Memory MCP Integration
- Store findings, decisions, and patterns in memory for cross-session learning
- Reference previous analysis and build upon established knowledge
- Tag entries appropriately for organization and retrieval

### Sequential Thinking MCP Usage  
- Use `mcp__sequential-thinking__sequentialthinking` for complex analysis and reasoning
- Break down complex problems into systematic thinking steps
- Allow thoughts to evolve and build upon previous insights
- Question assumptions and explore alternative approaches
- Generate and verify solution hypotheses through structured reasoning

### üß† Zen MCP Integration (CRITICAL FOR SECURITY ANALYSIS)
**Use Zen tools for comprehensive security assessment:**
- **`mcp__zen__codereview`** - Deep security-focused code review
  ```bash
  mcp__zen__codereview
    files=["src/auth/", "src/api/", "src/db/", "src/crypto/"]
    prompt="Perform security-focused code review identifying vulnerabilities, insecure patterns, and OWASP Top 10 issues"
    model="pro"
    review_type="security"
    severity_filter="all"
  ```
- **`mcp__zen__thinkdeep`** - Explore attack vectors and exploit scenarios
  ```bash
  mcp__zen__thinkdeep
    prompt="Analyze potential attack vectors and security implications for identified vulnerabilities"
    model="pro"
    thinking_mode="high"
    focus_areas=["authentication", "authorization", "injection", "data_exposure"]
  ```
- **`mcp__zen__debug`** - Root cause analysis for security issues
- **Benefits**: Comprehensive vulnerability identification, severity assessment, exploit analysis

### üöÄ Task Tool Usage (ESSENTIAL FOR VULNERABILITY DISCOVERY)
**Use Task tool for systematic security scanning:**
```bash
Task(
  description="Security vulnerability scan",
  prompt="Search for security vulnerabilities including:
    1. Authentication and authorization flaws (missing checks, weak tokens)
    2. Injection vulnerabilities (SQL, NoSQL, command, LDAP)
    3. Sensitive data exposure (hardcoded secrets, logging PII)
    4. Insecure cryptography (weak algorithms, poor key management)
    5. Input validation issues (XSS, path traversal)
    6. Insecure dependencies and configurations
    7. Session management flaws
    8. CORS and security header misconfigurations"
)
```
**Benefits**: Comprehensive vulnerability coverage, pattern-based detection, efficient scanning

This multi-tool approach enables thorough security analysis and vulnerability discovery.

---

You are a security researcher specializing in application security and vulnerability assessment. Your goal is to discover and document ACTUAL security vulnerabilities through systematic code exploration.

## üö® CRITICAL: Discovery-First Security Analysis

**MANDATORY PROCESS:**
1. **VERIFY** components and APIs from prompts #1-6
2. **DISCOVER** actual security vulnerabilities in real code
3. **VALIDATE** every vulnerability with file:line evidence
4. **ASSESS** actual risk based on code patterns found
5. **NEVER** create hypothetical vulnerabilities or example attacks

## üîó Prompt Chaining Rules

**CRITICAL: This is prompt #7 in the analysis chain.**

## üîç Smart Dependency Validation

**MANDATORY: Execute this validation before proceeding with security analysis**

```bash
## Enhanced Security Analysis Dependency Validation

validate_security_prerequisites() {
  echo "=== Validating Prerequisites for Security Analysis ==="
  
  local required_files=(
    "docs/code-review/1-CODEBASE_OVERVIEW.md:Codebase Overview:5"
    "docs/code-review/2-ARCHITECTURE_ANALYSIS.md:Architecture Analysis:3"
    "docs/code-review/3-API_CONTRACT_ANALYSIS.md:API Analysis:3"
  )
  
  local validated_files=0
  local total_evidence=0
  
  for file_info in "${required_files[@]}"; do
    IFS=':' read -r file name min_evidence <<< "$file_info"
    
    if [ ! -f "$file" ]; then
      echo "‚ö†Ô∏è  OPTIONAL: $name not found ($file)"
      echo "   Security analysis can proceed but will have limited scope"
      continue
    fi
    
    local evidence_count=$(grep -c ":[0-9]\+" "$file" 2>/dev/null || echo "0")
    local component_count=$(grep -c "‚úì.*FOUND\|‚úì.*Component\|‚úì.*VERIFIED" "$file" 2>/dev/null || echo "0")
    
    if [ "$evidence_count" -ge "$min_evidence" ] && [ "$component_count" -gt 0 ]; then
      echo "‚úÖ VALIDATED: $name ($evidence_count evidence, $component_count findings)"
      ((validated_files++))
      ((total_evidence += evidence_count))
    else
      echo "‚ö†Ô∏è  INCOMPLETE: $name has insufficient evidence ($evidence_count/$min_evidence)"
    fi
  done
  
  if [ "$validated_files" -eq 0 ]; then
    echo "‚ùå ERROR: No validated prerequisite analyses found"
    echo "Security analysis requires at least codebase overview to identify scan targets"
    echo "Please run prompt #1 first to discover components"
    exit 1
  fi
  
  echo "‚úÖ Prerequisites validated: $validated_files analyses with $total_evidence total evidence points"
  echo "‚úÖ Security analysis can proceed with discovered components"
}

# Validate dependencies
validate_security_prerequisites

# Extract security-relevant components from previous analyses
echo "=== Loading security-relevant components ==="

# Get authentication/auth components
AUTH_COMPONENTS=$(find docs/code-review/ -name "*.md" -exec grep -l "auth\|login\|password\|token\|session" {} \; 2>/dev/null | head -3)
if [ -n "$AUTH_COMPONENTS" ]; then
  echo "‚úÖ Found authentication-related components in previous analyses"
  AUTH_DETAILS=$(grep -h "auth\|login\|password\|token" $AUTH_COMPONENTS | grep "file:\|Path:\|‚úì" | head -5)
  echo "$AUTH_DETAILS"
fi

# Get API endpoints for security scanning
API_ENDPOINTS=""
if [ -f "docs/code-review/3-API_CONTRACT_ANALYSIS.md" ]; then
  API_ENDPOINTS=$(grep -E "POST|GET|PUT|DELETE" docs/code-review/3-API_CONTRACT_ANALYSIS.md | head -10)
  if [ -n "$API_ENDPOINTS" ]; then
    echo "‚úÖ Found API endpoints for security analysis:"
    echo "$API_ENDPOINTS" | head -3
  fi
fi

# Get component paths for vulnerability scanning
SCAN_PATHS=""
if [ -f "docs/code-review/2-ARCHITECTURE_ANALYSIS.md" ]; then
  SCAN_PATHS=$(grep -oE "Path:.*\/" docs/code-review/2-ARCHITECTURE_ANALYSIS.md | sed 's/Path: *//' | sort -u)
  if [ -n "$SCAN_PATHS" ]; then
    echo "‚úÖ Component paths available for security scanning:"
    echo "$SCAN_PATHS"
  fi
fi
```

**Input Validation:**
- **REQUIRED**: At least codebase overview to identify security scan targets  
- **OPTIMAL**: Architecture analysis and API analysis for comprehensive security coverage
- **USE**: Verified components, API endpoints, and paths from previous analyses as security scan targets
- **FOCUS**: Security analysis on actual discovered components, not hypothetical code
- **GRACEFUL**: Continue with reduced scope if some prerequisite analyses are missing

**Evidence Requirements:**
- Every vulnerability MUST have file:line reference
- Every security issue MUST show actual vulnerable code
- Every risk assessment MUST cite real patterns
- Every remediation MUST address a found vulnerability
- NO example CVEs without actual package.json evidence

## üß† Enhanced Memory Integration

**MANDATORY: Execute memory operations for security chain continuity**

```bash
## Standardized Memory Operations for Security Analysis

# Initialize security analysis memory context
initialize_security_memory_context() {
  echo "=== Initializing Memory Context for Security Analysis ==="
  
  # Retrieve previous security insights and vulnerability patterns
  PREVIOUS_SECURITY=$(memory_read operation="search" \
    options='{"query":"security vulnerability authentication authorization","repository":"'$REPO_URL'"}')
  
  if [ -n "$PREVIOUS_SECURITY" ]; then
    echo "‚úÖ Retrieved previous security insights:"
    echo "$PREVIOUS_SECURITY" | head -3
    echo "Building upon previous security understanding..."
  else
    echo "‚ÑπÔ∏è  No previous security context found - performing fresh security analysis"
  fi
  
  # Get component security context from architecture analysis
  COMPONENT_SECURITY=$(memory_read operation="search" \
    options='{"query":"component authentication API security file:","repository":"'$REPO_URL'"}')
  
  if [ -n "$COMPONENT_SECURITY" ]; then
    echo "‚úÖ Found security-relevant components from previous analysis:"
    echo "$COMPONENT_SECURITY" | head -2
  fi
  
  # Look for known vulnerability patterns
  VULNERABILITY_PATTERNS=$(memory_read operation="find_similar" \
    options='{"problem":"security vulnerability assessment and threat analysis","repository":"'$REPO_URL'"}')
  
  if [ -n "$VULNERABILITY_PATTERNS" ]; then
    echo "üí° Similar vulnerability patterns found:"
    echo "$VULNERABILITY_PATTERNS" | head -2
  fi
}

# Store security findings with evidence and severity
store_security_findings() {
  local vulnerability_count=$1
  local critical_count=$2
  local evidence_summary=$3
  
  echo "=== Storing Security Analysis Findings ==="
  
  # Store vulnerability inventory
  memory_store_chunk \
    content="Security Analysis: Found $vulnerability_count vulnerabilities ($critical_count critical). Evidence: $evidence_summary" \
    tags=["security", "vulnerabilities", "verified", "prompt-7", "analysis-chain"] \
    repository="$REPO_URL" \
    session_id="$SESSION_ID"
  
  # Store critical security decisions
  if [ "$critical_count" -gt 0 ]; then
    memory_store_decision \
      decision="Critical security vulnerabilities found requiring immediate attention" \
      rationale="Security analysis identified $critical_count critical vulnerabilities with file:line evidence. These are production blockers." \
      context="Prompt #7 security analysis - critical for production readiness assessment" \
      repository="$REPO_URL" \
      session_id="$SESSION_ID"
  fi
  
  # Store security findings for cross-reference by test and production readiness analysis
  memory_store_chunk \
    content="Security vulnerabilities for testing priority: $SECURITY_CRITICAL_COMPONENTS" \
    tags=["security-testing", "critical-components", "prompt-7", "for-test-analysis"] \
    repository="$REPO_URL" \
    session_id="$SESSION_ID"
  
  echo "‚úÖ Security findings stored for chain continuity"
}

# Get security insights and suggestions
get_security_insights() {
  echo "=== Checking for Security Analysis Insights ==="
  
  # Get AI suggestions for security focus areas
  AI_SECURITY_SUGGESTIONS=$(memory_intelligence operation="suggest_related" \
    options='{"current_context":"performing security vulnerability assessment and threat analysis","repository":"'$REPO_URL'","session_id":"'$SESSION_ID'"}')
  
  if [ -n "$AI_SECURITY_SUGGESTIONS" ]; then
    echo "ü§ñ AI suggestions for security analysis focus:"
    echo "$AI_SECURITY_SUGGESTIONS" | head -2
  fi
  
  # Check for security patterns and anti-patterns
  SECURITY_PATTERNS=$(memory_read operation="search" \
    options='{"query":"authentication patterns security best practices","repository":"'$REPO_URL'"}')
  
  if [ -n "$SECURITY_PATTERNS" ]; then
    echo "üí° Previous security patterns and best practices:"
    echo "$SECURITY_PATTERNS" | head -2
  fi
}

# Execute security memory operations
initialize_security_memory_context
get_security_insights
```

**Chain Foundation:**
- Store verified vulnerabilities with tags: `["security", "vulnerabilities", "verified", "prompt-7", "analysis-chain"]`
- Create security component registry for test coverage prioritization
- Store critical security decisions for production readiness blocking
- Enable memory-driven insights for vulnerability pattern recognition

## File Organization

**REQUIRED OUTPUT LOCATIONS:**

- `docs/code-review/7-SECURITY_ANALYSIS.md` - Complete security assessment with remediation plan
- `scripts/security-monitor.js` - Automated security monitoring script

**IMPORTANT RULES:**

- Focus on critical vulnerabilities first (CVSS 7.0+)
- Identify authentication and authorization flaws
- Check for injection vulnerabilities and cryptographic issues
- Provide practical remediation with code examples

## 0. Session Initialization

```
memory_tasks session_create session_id="security-$(date +%s)" repository="github.com/org/repo"
memory_get_context repository="github.com/org/repo"
memory_read operation="search" options='{"query":"security vulnerabilities authentication","repository":"github.com/org/repo"}'
```

## 1. Validate Previous Findings First

### Step 1: Load and Verify Components from Prior Analysis

```bash
# FIRST: Verify previous analyses exist and are valid
echo "=== Loading verified components from previous prompts ==="

# Check for required previous analyses
for i in {1..6}; do
  if [ -f "docs/code-review/${i}-*.md" ]; then
    echo "‚úì Found analysis from prompt #$i"
  else
    echo "‚úó MISSING: Analysis from prompt #$i - security analysis may be incomplete"
  fi
done

# Extract verified API endpoints for attack surface mapping
echo "=== API endpoints to analyze for security ==="
if [ -f "docs/code-review/3-API_CONTRACT_ANALYSIS.md" ]; then
  grep -E "Endpoint:.*\[|Method|File:" docs/code-review/3-API_CONTRACT_ANALYSIS.md
fi

# Get verified components for focused security scanning
echo "=== Components to scan for vulnerabilities ==="
if [ -f "docs/code-review/2-ARCHITECTURE_ANALYSIS.md" ]; then
  grep -E "‚úì COMPONENT:|Path:|Evidence:" docs/code-review/2-ARCHITECTURE_ANALYSIS.md
fi
```

## 2. Discover Actual Security Vulnerabilities

### Step 2: Find Real Authentication Issues with Evidence

```bash
echo "=== Searching for actual authentication vulnerabilities ==="

# First, find actual authentication code files
AUTH_FILES=$(find . -name "*.js" -o -name "*.ts" | xargs grep -l "auth\|login\|jwt\|token" 2>/dev/null | grep -v node_modules | head -20)

# Check for hardcoded secrets in real files
echo "--- Hardcoded Credentials Check ---"
for file in $AUTH_FILES; do
  if [ -f "$file" ]; then
    # Look for actual hardcoded values
    grep -n "password.*=.*[\"'][^\"']*[\"']\|secret.*=.*[\"'][^\"']*[\"']\|key.*=.*[\"'][^\"']*[\"']" "$file" 2>/dev/null | \
      grep -v "process.env\|env\.\|config\." | head -5
  fi
done

# Find weak session management patterns
echo "--- Session Security Issues ---"
for file in $AUTH_FILES; do
  if [ -f "$file" ]; then
    # Check for predictable session generation
    grep -n "Math\.random\|Date\.now\|timestamp" "$file" 2>/dev/null | \
      grep -E "session|token|id" | head -5
  fi
done
```

### Step 3: Find Real Injection Vulnerabilities

```bash
echo "=== Searching for actual injection vulnerabilities ==="

# Get actual source files to scan
SOURCE_FILES=$(find . -name "*.js" -o -name "*.ts" -o -name "*.go" -o -name "*.py" | grep -v node_modules | head -50)

# SQL Injection - Look for actual string concatenation in queries
echo "--- SQL Injection Patterns ---"
for file in $SOURCE_FILES; do
  if [ -f "$file" ]; then
    # Find actual query building with concatenation
    SQL_CONCAT=$(grep -n "query.*+\|WHERE.*\${.*}\|SELECT.*+" "$file" 2>/dev/null)
    if [ -n "$SQL_CONCAT" ]; then
      echo "FOUND in $file:"
      echo "$SQL_CONCAT" | head -3
    fi
  fi
done

# Command Injection - Find actual exec calls
echo "--- Command Injection Risks ---"
for file in $SOURCE_FILES; do
  if [ -f "$file" ]; then
    # Look for exec/spawn with user input
    CMD_INJECTION=$(grep -n "exec\|spawn\|system" "$file" 2>/dev/null | grep -v "^[[:space:]]*//\|^[[:space:]]*\*")
    if [ -n "$CMD_INJECTION" ]; then
      echo "FOUND in $file:"
      echo "$CMD_INJECTION" | head -3
      # Check if user input flows to these commands
      grep -n -B5 -A5 "exec\|spawn" "$file" 2>/dev/null | grep -E "req\.|params\.|body\.|query\." | head -3
    fi
  fi
done

# XSS - Find actual unsafe DOM manipulation
echo "--- XSS Vulnerabilities ---"
UI_FILES=$(find . -name "*.jsx" -o -name "*.tsx" -o -name "*.js" | grep -v node_modules | head -30)
for file in $UI_FILES; do
  if [ -f "$file" ]; then
    XSS_PATTERNS=$(grep -n "innerHTML\|dangerouslySetInnerHTML\|document\.write" "$file" 2>/dev/null)
    if [ -n "$XSS_PATTERNS" ]; then
      echo "FOUND in $file:"
      echo "$XSS_PATTERNS"
    fi
  fi
done
```

### Step 4: Find Real Cryptographic Issues

```bash
echo "=== Searching for cryptographic vulnerabilities ==="

# Weak algorithms in actual use
echo "--- Weak Cryptographic Algorithms ---"
for file in $SOURCE_FILES; do
  if [ -f "$file" ]; then
    WEAK_CRYPTO=$(grep -n "createHash.*['\"]md5\|createHash.*['\"]sha1" "$file" 2>/dev/null)
    if [ -n "$WEAK_CRYPTO" ]; then
      echo "WEAK ALGORITHM in $file:"
      echo "$WEAK_CRYPTO"
    fi
  fi
done

# Predictable randomness for security features
echo "--- Insufficient Randomness ---"
for file in $SOURCE_FILES; do
  if [ -f "$file" ]; then
    # Check if Math.random is used for security
    BAD_RANDOM=$(grep -n "Math\.random" "$file" 2>/dev/null | grep -E "token|session|password|key|salt")
    if [ -n "$BAD_RANDOM" ]; then
      echo "INSECURE RANDOM in $file:"
      echo "$BAD_RANDOM"
    fi
  fi
done
```

## 3. Analyze Configuration Security

### Step 5: Find Real Configuration Issues

```bash
echo "=== Checking configuration security ==="

# First check if .env files are properly gitignored
echo "--- Checking for exposed environment files ---"
if [ -f ".gitignore" ]; then
  grep -q "\.env" .gitignore || echo "‚ö†Ô∏è  WARNING: .env not in .gitignore"
fi

# Find actual exposed secrets
echo "--- Exposed Secrets in Tracked Files ---"
git ls-files 2>/dev/null | while read file; do
  if [ -f "$file" ]; then
    SECRETS=$(grep -n "api[_-]key.*=.*[\"'][^\"']*[\"']\|password.*=.*[\"'][^\"']*[\"']" "$file" 2>/dev/null | \
              grep -v "process\.env\|ENV\|example\|placeholder")
    if [ -n "$SECRETS" ]; then
      echo "EXPOSED SECRET in $file:"
      echo "$SECRETS"
    fi
  fi
done

# Check actual debug settings
echo "--- Debug Mode in Production ---"
CONFIG_FILES=$(find . -name "*.config.*" -o -name "*.env*" | grep -v node_modules | head -20)
for file in $CONFIG_FILES; do
  if [ -f "$file" ]; then
    DEBUG_ENABLED=$(grep -n "debug.*true\|DEBUG.*true\|NODE_ENV.*development" "$file" 2>/dev/null)
    if [ -n "$DEBUG_ENABLED" ]; then
      echo "DEBUG ENABLED in $file:"
      echo "$DEBUG_ENABLED"
    fi
  fi
done

# Check for actual security header implementation
echo "--- Security Headers Check ---"
EXPRESS_FILES=$(find . -name "*.js" -o -name "*.ts" | xargs grep -l "express\|app\." 2>/dev/null | grep -v node_modules | head -10)
HEADERS_MISSING=0
for file in $EXPRESS_FILES; do
  if [ -f "$file" ]; then
    # Check if security headers are set
    HAS_HELMET=$(grep -n "helmet\|security.*header" "$file" 2>/dev/null)
    if [ -z "$HAS_HELMET" ]; then
      HAS_APP=$(grep -n "app\.\|express()" "$file" 2>/dev/null | head -1)
      if [ -n "$HAS_APP" ]; then
        echo "‚ùå NO SECURITY HEADERS in Express app: $file:$(echo "$HAS_APP" | cut -d: -f2)"
        ((HEADERS_MISSING++))
      fi
    else
      echo "‚úì Security headers found in $file"
    fi
  fi
done
echo "Total Express apps without security headers: $HEADERS_MISSING"
```

## 4. Generate Evidence-Based Security Report

### CRITICAL: Document Only Discovered Vulnerabilities

Create `docs/code-review/7-SECURITY_ANALYSIS.md` with ONLY verified findings:

````markdown
# Security Analysis - VERIFIED FINDINGS ONLY

## Discovery Summary

**Analysis Date**: [Current date]
**Files Scanned**: [Actual count from SOURCE_FILES]
**Authentication Files**: [Count from AUTH_FILES]
**Vulnerabilities Found**: [Actual count with evidence]

## Executive Summary

**IMPORTANT**: Risk level based on actual findings only.

**Risk Level**: [Based on actual vulnerabilities found]
**Critical Issues Found**: [Count of actual critical vulnerabilities]
**Total Security Issues**: [Count of all verified issues]

## Verified Vulnerabilities

### Critical Security Issues

[Only document if found in Steps 2-5]

#### VULN-001: [Actual Vulnerability Type]
- **File**: `[actual-file.js:line]`
- **Evidence**:
  ```javascript
  // [Actual vulnerable code from discovery]
  ```
- **Risk**: [Explain actual risk based on code]
- **CVSS**: [Calculate based on actual vulnerability]

### Authentication & Authorization Issues

[Only document if found in Step 2]

#### Hardcoded Credentials
**Files with hardcoded secrets**:
[List actual files:lines found in scan]

#### Weak Session Management
**Files using predictable randomness**:
[List actual files:lines where Math.random used for tokens]

### Injection Vulnerabilities

[Only document if found in Step 3]

#### SQL Injection Risks
**Query concatenation found in**:
[List actual files:lines with evidence]

#### Command Injection Risks
**Unsafe exec/spawn usage**:
[List actual files:lines]

### Cryptographic Issues

[Only document if found in Step 4]

#### Weak Algorithms
**MD5/SHA1 usage found**:
[List actual files:lines]

### Configuration Security

[Only document if found in Step 5]

#### Exposed Secrets
**Secrets in tracked files**:
[List actual findings]

#### Missing Security Headers
**Express apps without security headers**:
[List actual files]

## NOT FOUND (Security Elements Checked But Missing)

### Expected But Not Found
- ‚ùå Rate limiting middleware: NOT FOUND
- ‚ùå CSRF protection: NOT FOUND
- ‚ùå Input validation middleware: NOT FOUND
- ‚ùå Security headers (helmet.js): NOT FOUND in [X] Express apps
- ‚ùå Secure session configuration: NOT FOUND

## Attack Surface Analysis (From Actual Endpoints)

[Only include if API endpoints were found in prompt #3]

### Verified Entry Points
| Endpoint | File | Auth Status | Security Issue |
|----------|------|-------------|----------------|
| [Actual endpoint] | [file:line] | [Found/Not Found] | [Actual issue] |

## Remediation for Discovered Issues

[Only provide fixes for actual vulnerabilities found]

### Fix: [Actual Vulnerability]
**Current vulnerable code** at `[file:line]`:
```javascript
[Actual code]
```

**Secure implementation**:
```javascript
[Fixed code]
```
````

## 5. Check Dependency Vulnerabilities

### Step 6: Analyze Actual Package Vulnerabilities

```bash
echo "=== Checking for dependency vulnerabilities ==="

# Check if package.json exists
if [ -f "package.json" ]; then
  echo "--- NPM Audit Analysis ---"
  # Run actual npm audit
  npm audit --json > temp-audit.json 2>/dev/null || true
  
  if [ -f "temp-audit.json" ]; then
    # Extract actual vulnerabilities
    VULN_COUNT=$(jq '.vulnerabilities | length' temp-audit.json 2>/dev/null || echo "0")
    if [ "$VULN_COUNT" -gt "0" ]; then
      echo "FOUND $VULN_COUNT vulnerable packages:"
      jq -r '.vulnerabilities | to_entries[] | "\(.key) - Severity: \(.value.severity)"' temp-audit.json 2>/dev/null | head -10
    fi
    rm -f temp-audit.json
  fi
elif [ -f "go.mod" ]; then
  echo "--- Go Module Vulnerability Check ---"
  govulncheck ./... 2>/dev/null || echo "govulncheck not installed"
elif [ -f "requirements.txt" ]; then
  echo "--- Python Package Safety Check ---"
  safety check 2>/dev/null || echo "safety not installed"
fi
```

### Step 7: Find Missing Security Controls

```bash
echo "=== Checking for missing security controls ==="

# Check for rate limiting implementation
echo "--- Rate Limiting Check ---"
RATE_LIMIT=$(grep -rn "rate.*limit\|rateLimit\|express-rate-limit" . --include="*.js" --include="*.ts" 2>/dev/null | grep -v node_modules)
if [ -z "$RATE_LIMIT" ]; then
  echo "‚ùå NO RATE LIMITING FOUND"
else
  echo "‚úì Rate limiting found:"
  echo "$RATE_LIMIT" | head -3
fi

# Check for CSRF protection
echo "--- CSRF Protection Check ---"
CSRF=$(grep -rn "csrf\|csurf" . --include="*.js" --include="*.ts" 2>/dev/null | grep -v node_modules)
if [ -z "$CSRF" ]; then
  echo "‚ùå NO CSRF PROTECTION FOUND"
else
  echo "‚úì CSRF protection found:"
  echo "$CSRF" | head -3
fi

# Check for input validation
echo "--- Input Validation Check ---"
VALIDATION=$(grep -rn "joi\|yup\|express-validator\|zod" . --include="*.js" --include="*.ts" 2>/dev/null | grep -v node_modules)
if [ -z "$VALIDATION" ]; then
  echo "‚ùå NO INPUT VALIDATION LIBRARY FOUND"
else
  echo "‚úì Input validation found:"
  echo "$VALIDATION" | head -3
fi
```

## 6. Validation Before Documentation

### Verify All Security Findings

```bash
echo "=== Validating security findings ===="

# Count actual vulnerabilities found
HARDCODED_COUNT=$(grep -c "FOUND in" security-scan.log 2>/dev/null || echo "0")
SQL_INJECTION_COUNT=$(grep -c "SQL.*FOUND" security-scan.log 2>/dev/null || echo "0")
XSS_COUNT=$(grep -c "XSS.*FOUND" security-scan.log 2>/dev/null || echo "0")

echo "Documented vulnerabilities:"
echo "- Hardcoded secrets: $HARDCODED_COUNT"
echo "- SQL injection risks: $SQL_INJECTION_COUNT"
echo "- XSS vulnerabilities: $XSS_COUNT"

# Ensure all findings have file:line references
echo "=== Checking evidence quality ===="
EVIDENCE_COUNT=$(grep -c ":[0-9]" security-scan.log 2>/dev/null || echo "0")
echo "Findings with file:line evidence: $EVIDENCE_COUNT"
```

### Documentation Checklist

Before saving the security analysis:
- [ ] Every vulnerability has file:line evidence
- [ ] Every security issue shows actual code
- [ ] All remediations address found problems
- [ ] No example vulnerabilities included
- [ ] Missing security controls documented
- [ ] "NOT FOUND" section lists expected but missing items

## 7. Create Security Monitoring Script

### Only If Vulnerabilities Were Found

```bash
# Only create monitoring script if vulnerabilities discovered
if [ "$HARDCODED_COUNT" -gt 0 ] || [ "$SQL_INJECTION_COUNT" -gt 0 ] || [ "$XSS_COUNT" -gt 0 ]; then
  cat > scripts/security-monitor.js << 'EOF'
#!/usr/bin/env node

// Security monitoring for discovered vulnerabilities
const vulnerabilities = {
  hardcodedSecrets: [/* List actual files with hardcoded secrets */],
  sqlInjection: [/* List actual files with SQL concatenation */],
  xssRisks: [/* List actual files with innerHTML usage */],
  missingControls: {
    rateLimiting: /* true/false based on discovery */,
    csrf: /* true/false based on discovery */,
    inputValidation: /* true/false based on discovery */
  }
};

// Monitor only actual vulnerabilities found during analysis
console.log('Monitoring vulnerabilities:', vulnerabilities);

// Add specific checks based on what was actually found
EOF
fi
```

```

memory_store_chunk
content="Security analysis completed. Vulnerabilities found: [actual count]. Missing controls: [list]. All findings verified with file:line evidence."
session_id="security-$(date +%s)"
repository="github.com/org/repo"
tags=["security", "vulnerabilities", "verified", "evidence-based"]

memory_store_decision
decision="Security implementation status: [needs-improvement|partially-secure|secure]"
rationale="Found [X] actual vulnerabilities with evidence, [Y] missing security controls. Focus areas: [specific findings]"
context="Discovery-based analysis found: [summary of actual findings]"
session_id="security-$(date +%s)"
repository="github.com/org/repo"

memory_tasks session_end session_id="security-$(date +%s)" repository="github.com/org/repo"

```

## Execution Notes

- **Discovery First**: Find actual vulnerabilities before documenting
- **Evidence Required**: Every finding must have file:line reference
- **No Examples**: Document only real vulnerabilities found in code
- **Missing Controls**: Clearly document expected but missing security features
- **Language Agnostic**: Adapts search patterns to any technology stack

## üìã Todo List Generation

**REQUIRED**: Generate or append to `docs/code-review/code-review-todo-list.md` with findings from this analysis.

### Todo Entry Format - EVIDENCE-BASED ONLY
```markdown
## Security Vulnerability Analysis Findings

**Analysis Date**: [Date]
**Files Scanned**: [Count]
**Vulnerabilities Found**: [Count with evidence]
**Missing Controls**: [Count]

### üî¥ CRITICAL (Immediate Action Required)
[Only if critical vulnerabilities found with evidence]
- [ ] **Fix [Vulnerability Type] in [Component]**: Found at `[file:line]`
  - **Evidence**: [Actual vulnerable code found]
  - **Risk**: [Actual risk based on code]
  - **Effort**: [Time to fix]
  - **CVSS**: [Score if applicable]

### üü° HIGH (Sprint Priority)
[Only for verified security issues]
- [ ] **Remove hardcoded [secret type]**: Found at `[file:line]`
  - **Evidence**: [Actual hardcoded value pattern]
  - **Risk**: [Exposure risk]
  - **Fix**: Move to environment variable

### üü¢ MEDIUM (Backlog)
[Only for actual findings]
- [ ] **Implement [missing control]**: Not found in codebase
  - **Searched**: [Where you looked]
  - **Risk**: [What attacks this enables]
  - **Solution**: [Specific implementation]

### üîµ LOW (Future Consideration)
[Minor issues with evidence]

### ‚ùå MISSING SECURITY CONTROLS
- [ ] **No rate limiting found**
  - **Searched**: All API endpoints in [files]
  - **Risk**: DoS and brute force attacks
  - **Recommendation**: Implement express-rate-limit
- [ ] **No CSRF protection found**
  - **Searched**: Form handlers and state-changing endpoints
  - **Risk**: Cross-site request forgery
- [ ] **No input validation library**
  - **Searched**: API route handlers
  - **Risk**: Injection attacks and data integrity
```

### Implementation Rules
1. ONLY create todos for vulnerabilities found in actual code
2. EVERY vulnerability must have file:line evidence
3. EVERY missing control must document where it was searched for
4. NO hypothetical vulnerabilities or example CVEs
5. Include "MISSING" section for expected security features
6. Tag with `#security #verified` and specific vulnerability types