---
description: 
globs: 
alwaysApply: false
---
---
description: Guidelines for developing, deploying, and managing serverless functions, including best practices and performance optimization
globs:
- src/**/*.{ts,tsx}
alwaysApply: false
---

# Serverless Functions Guidelines

This document outlines best practices for implementing serverless functions in our Next.js application, covering both API Routes and Server Actions.

## Next.js API Routes

### Route Organization

- Place API routes in the `app/api` directory following the App Router pattern
- Organize routes by domain (e.g., `app/api/accounts`, `app/api/transactions`)
- Use dynamic segments for resource identifiers (e.g., `app/api/accounts/[accountId]/route.ts`)
- Group related routes in meaningful directories
- Implement proper HTTP methods in each route file

```typescript
// app/api/accounts/[accountId]/route.ts
import { NextRequest } from 'next/server';
import { getAccountById } from '@/core/application/use-cases/accounts';

export async function GET(
  request: NextRequest,
  { params }: { params: { accountId: string } }
) {
  try {
    const account = await getAccountById(params.accountId);

    if (!account) {
      return Response.json(
        { error: 'Account not found' },
        { status: 404 }
      );
    }

    return Response.json(account);
  } catch (error) {
    console.error('Failed to fetch account:', error);
    return Response.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Request Handling

- Validate incoming data with Zod schemas
- Use proper status codes for responses
- Implement consistent error response format
- Parse and validate query parameters
- Handle multi-part form data properly
- Set appropriate headers for security and caching

```typescript
// app/api/accounts/route.ts
import { NextRequest } from 'next/server';
import { z } from 'zod';
import { createAccount } from '@/core/application/use-cases/accounts';

// Request schema
const createAccountSchema = z.object({
  name: z.string().min(2).max(100),
  type: z.enum(['checking', 'savings', 'investment']),
  currency: z.string().length(3),
  balance: z.number().optional(),
});

export async function POST(request: NextRequest) {
  try {
    // Parse and validate the request body
    const body = await request.json();
    const result = createAccountSchema.safeParse(body);

    if (!result.success) {
      return Response.json(
        {
          error: 'Validation error',
          details: result.error.format()
        },
        { status: 400 }
      );
    }

    // Process the validated data
    const account = await createAccount(result.data);

    // Return the created resource with appropriate status
    return Response.json(
      account,
      {
        status: 201,
        headers: {
          'Location': `/api/accounts/${account.id}`
        }
      }
    );
  } catch (error) {
    console.error('Failed to create account:', error);
    return Response.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Authentication and Authorization

- Implement middleware for authentication checks
- Use NextAuth.js session handling
- Apply role-based access control
- Validate permissions for each operation
- Log security-related events
- Use rate limiting for sensitive endpoints

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getToken } from 'next-auth/jwt';

export const config = {
  matcher: ['/api/((?!auth/signin).*)'],
};

export async function middleware(request: NextRequest) {
  // Get the token from the request
  const token = await getToken({ req: request });

  // Check if the user is authenticated
  if (!token) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  // Continue with the request
  return NextResponse.next();
}
```

## Server Actions

### Action Organization

- Place server actions in the `app/actions` or `src/actions` directory
- Organize actions by domain or feature
- Use descriptive filenames that indicate the action's purpose
- Mark server action files with the `'use server'` directive
- Export named functions for each action

```typescript
// app/actions/accounts/create-account.ts
'use server';

import { z } from 'zod';
import { createAccount } from '@/core/application/use-cases/accounts';
import { getCurrentUser } from '@/lib/auth';
import { revalidatePath } from 'next/cache';

const createAccountSchema = z.object({
  name: z.string().min(2).max(100),
  type: z.enum(['checking', 'savings', 'investment']),
  currency: z.string().length(3),
});

export async function createAccountAction(formData: FormData) {
  // Authentication check
  const user = await getCurrentUser();
  if (!user) {
    return { error: 'Unauthorized' };
  }

  // Validation
  const parsed = createAccountSchema.safeParse(
    Object.fromEntries(formData.entries())
  );

  if (!parsed.success) {
    return {
      error: 'Validation failed',
      fields: parsed.error.format()
    };
  }

  try {
    // Execute the business logic
    const account = await createAccount({
      ...parsed.data,
      userId: user.id,
    });

    // Revalidate relevant paths
    revalidatePath('/accounts');

    return {
      success: true,
      data: account
    };
  } catch (error) {
    console.error('Failed to create account:', error);
    return {
      error: 'Failed to create account'
    };
  }
}
```

### Form Integration

- Use the `action` attribute on forms for server actions
- Implement progressive enhancement for JavaScript-disabled clients
- Provide proper loading and error states
- Use `useFormStatus` and `useFormState` for client-side feedback
- Handle file uploads with appropriate validation

```typescript
// app/accounts/new/page.tsx
'use client';

import { useFormState, useFormStatus } from 'react-dom';
import { createAccountAction } from '@/app/actions/accounts/create-account';

function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <button
      type="submit"
      disabled={pending}
      className="btn btn-primary"
    >
      {pending ? 'Creating...' : 'Create Account'}
    </button>
  );
}

export default function NewAccountPage() {
  const [state, formAction] = useFormState(createAccountAction, {});

  return (
    <div>
      <h1>Create New Account</h1>

      <form action={formAction}>
        {state.error && (
          <div className="alert alert-error">{state.error}</div>
        )}

        <div className="form-group">
          <label htmlFor="name">Account Name</label>
          <input
            id="name"
            name="name"
            type="text"
            className="form-control"
            aria-invalid={state.fields?.name ? 'true' : undefined}
          />
          {state.fields?.name && (
            <div className="form-error">{state.fields.name._errors.join(', ')}</div>
          )}
        </div>

        {/* Other form fields */}

        <SubmitButton />
      </form>
    </div>
  );
}
```

### Optimistic Updates

- Implement optimistic UI updates for better user experience
- Handle error states gracefully with fallbacks
- Use React's `useOptimistic` hook for client-side state
- Provide visual feedback during action processing
- Revalidate data after action completion

```typescript
// app/accounts/page.tsx
'use client';

import { useOptimistic } from 'react';
import { deleteAccountAction } from '@/app/actions/accounts/delete-account';

export default function AccountsPage({ accounts }) {
  const [optimisticAccounts, addOptimisticAccount] = useOptimistic(
    accounts,
    (state, accountId) => state.filter(account => account.id !== accountId)
  );

  async function handleDelete(accountId) {
    // Optimistically update UI
    addOptimisticAccount(accountId);

    // Perform actual deletion
    await deleteAccountAction(accountId);
  }

  return (
    <div>
      <h1>Your Accounts</h1>
      <ul>
        {optimisticAccounts.map(account => (
          <li key={account.id}>
            {account.name}
            <button
              onClick={() => handleDelete(account.id)}
              className="btn btn-danger btn-sm"
            >
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## Performance Optimization

### Caching Strategies

- Use appropriate caching headers for API responses
- Implement `cache` directive for data fetching
- Leverage `revalidatePath` and `revalidateTag` for invalidation
- Use Incremental Static Regeneration (ISR) for semi-dynamic content
- Implement stale-while-revalidate patterns

```typescript
// app/api/accounts/route.ts
export async function GET() {
  const accounts = await getAccounts();

  return Response.json(
    accounts,
    {
      headers: {
        'Cache-Control': 'max-age=60, stale-while-revalidate=600',
      },
    }
  );
}

// Data fetching in server component
async function getAccounts() {
  const accounts = await fetch('https://api.example.com/accounts', {
    next: {
      revalidate: 60, // Revalidate every 60 seconds
      tags: ['accounts'],
    },
  });

  return accounts.json();
}
```

### Edge Runtime

- Use Edge Runtime for latency-sensitive functions
- Optimize for cold starts by minimizing dependencies
- Be aware of Edge Runtime limitations
- Use Streaming for progressive rendering
- Implement geographical routing where appropriate

```typescript
// app/api/status/route.ts
export const runtime = 'edge';

export async function GET() {
  const status = {
    status: 'ok',
    timestamp: new Date().toISOString(),
    region: process.env.VERCEL_REGION || 'unknown',
  };

  return Response.json(status);
}
```

### Resource Management

- Keep functions small and focused
- Minimize external dependencies
- Use connection pooling for database access
- Close resources properly (connections, file handles)
- Implement proper error handling and recovery

```typescript
// Database connection with connection pooling
import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
});

export async function query(text, params) {
  const client = await pool.connect();
  try {
    return await client.query(text, params);
  } finally {
    client.release();
  }
}
```

## Error Handling and Logging

### Structured Error Responses

- Use consistent error response format
- Include appropriate HTTP status codes
- Provide helpful error messages for clients
- Distinguish between client and server errors
- Handle expected errors gracefully

```typescript
// app/lib/api-error.ts
export class ApiError extends Error {
  public readonly statusCode: number;
  public readonly details?: any;

  constructor(message: string, statusCode: number, details?: any) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
  }

  static badRequest(message: string, details?: any) {
    return new ApiError(message, 400, details);
  }

  static notFound(message: string, details?: any) {
    return new ApiError(message, 404, details);
  }

  static unauthorized(message: string, details?: any) {
    return new ApiError(message, 401, details);
  }

  static forbidden(message: string, details?: any) {
    return new ApiError(message, 403, details);
  }

  static internal(message: string, details?: any) {
    return new ApiError(message, 500, details);
  }
}

// Error handler middleware
export function handleApiError(error: unknown) {
  console.error('API error:', error);

  if (error instanceof ApiError) {
    return Response.json(
      { error: error.message, details: error.details },
      { status: error.statusCode }
    );
  }

  return Response.json(
    { error: 'Internal server error' },
    { status: 500 }
  );
}
```

### Logging Best Practices

- Use structured logging with JSON format
- Include request IDs for traceability
- Log appropriate context information
- Implement different log levels (info, warn, error)
- Don't log sensitive information
- Use a proper logging service in production

```typescript
// app/lib/logger.ts
import pino from 'pino';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true,
    },
  },
});

export default logger;

// Usage in API route
import logger from '@/lib/logger';
import { nanoid } from 'nanoid';

export async function GET(request: NextRequest) {
  const requestId = nanoid();
  const url = request.url;

  logger.info({ requestId, url, method: 'GET' }, 'API request received');

  try {
    // Route implementation
    logger.info({ requestId }, 'API request successful');
    return Response.json({ success: true });
  } catch (error) {
    logger.error(
      { requestId, error, url, method: 'GET' },
      'API request failed'
    );
    return Response.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

## Testing Serverless Functions

### Unit Testing

- Test business logic independently from API handlers
- Mock external dependencies and services
- Use dependency injection for testability
- Test both success and error paths
- Validate input parsing and validation

```typescript
// __tests__/actions/create-account.test.ts
import { createAccountAction } from '@/app/actions/accounts/create-account';
import { getCurrentUser } from '@/lib/auth';
import { createAccount } from '@/core/application/use-cases/accounts';

// Mock dependencies
jest.mock('@/lib/auth', () => ({
  getCurrentUser: jest.fn(),
}));

jest.mock('@/core/application/use-cases/accounts', () => ({
  createAccount: jest.fn(),
}));

jest.mock('next/cache', () => ({
  revalidatePath: jest.fn(),
}));

describe('createAccountAction', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should create an account with valid data', async () => {
    // Arrange
    const formData = new FormData();
    formData.append('name', 'Test Account');
    formData.append('type', 'checking');
    formData.append('currency', 'USD');

    (getCurrentUser as jest.Mock).mockResolvedValue({ id: 'user-123' });
    (createAccount as jest.Mock).mockResolvedValue({
      id: 'account-123',
      name: 'Test Account',
      type: 'checking',
      currency: 'USD',
    });

    // Act
    const result = await createAccountAction(formData);

    // Assert
    expect(createAccount).toHaveBeenCalledWith({
      name: 'Test Account',
      type: 'checking',
      currency: 'USD',
      userId: 'user-123',
    });

    expect(result).toEqual({
      success: true,
      data: {
        id: 'account-123',
        name: 'Test Account',
        type: 'checking',
        currency: 'USD',
      },
    });
  });

  it('should return validation error with invalid data', async () => {
    // Arrange
    const formData = new FormData();
    formData.append('name', 'T'); // Too short
    formData.append('type', 'invalid'); // Invalid enum
    formData.append('currency', 'US'); // Invalid length

    (getCurrentUser as jest.Mock).mockResolvedValue({ id: 'user-123' });

    // Act
    const result = await createAccountAction(formData);

    // Assert
    expect(createAccount).not.toHaveBeenCalled();
    expect(result.error).toBe('Validation failed');
    expect(result.fields).toBeDefined();
  });
});
```

### Integration Testing

- Test complete API routes and server actions
- Use test utilities to create requests and parse responses
- Test authentication and authorization flows
- Validate HTTP status codes and response formats
- Mock external services but use real database where possible

```typescript
// __tests__/api/accounts.test.ts
import { createMocks } from 'node-mocks-http';
import { POST } from '@/app/api/accounts/route';

describe('Accounts API', () => {
  it('should create an account with valid data', async () => {
    // Arrange
    const { req } = createMocks({
      method: 'POST',
      body: {
        name: 'Test Account',
        type: 'checking',
        currency: 'USD',
      },
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Act
    const response = await POST(req);
    const data = await response.json();

    // Assert
    expect(response.status).toBe(201);
    expect(data).toHaveProperty('id');
    expect(data.name).toBe('Test Account');
  });

  it('should return 400 with invalid data', async () => {
    // Arrange
    const { req } = createMocks({
      method: 'POST',
      body: {
        name: 'T', // Too short
        type: 'invalid', // Invalid enum
      },
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Act
    const response = await POST(req);
    const data = await response.json();

    // Assert
    expect(response.status).toBe(400);
    expect(data.error).toBe('Validation error');
    expect(data.details).toBeDefined();
  });
});
```

## Security Considerations

### Input Validation

- Validate all input data on the server
- Use Zod for schema validation
- Sanitize user-generated content
- Validate file uploads thoroughly
- Implement proper type checking

### Rate Limiting

- Implement rate limiting for public-facing endpoints
- Use progressive penalties for repeated failures
- Apply stricter limits for authentication endpoints
- Consider IP-based and token-based rate limiting
- Log rate limit violations

```typescript
// app/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

// Create a new ratelimiter
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_URL,
  token: process.env.UPSTASH_REDIS_TOKEN,
});

const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '10 s'),
});

export async function middleware(request: NextRequest) {
  // Only rate limit API routes
  if (!request.nextUrl.pathname.startsWith('/api')) {
    return NextResponse.next();
  }

  // Get IP to rate limit by
  const ip = request.ip || 'anonymous';

  // Rate limit by IP
  const { success, limit, reset, remaining } = await ratelimit.limit(ip);

  if (!success) {
    return NextResponse.json(
      { error: 'Too Many Requests' },
      {
        status: 429,
        headers: {
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
          'X-RateLimit-Reset': reset.toString(),
          'Retry-After': Math.ceil((reset - Date.now()) / 1000).toString(),
        },
      }
    );
  }

  const response = NextResponse.next();

  // Add rate limit headers
  response.headers.set('X-RateLimit-Limit', limit.toString());
  response.headers.set('X-RateLimit-Remaining', remaining.toString());
  response.headers.set('X-RateLimit-Reset', reset.toString());

  return response;
}
```

### Secrets Management

- Never hardcode secrets in functions
- Use environment variables for configuration
- Validate environment variables at startup
- Rotate secrets regularly
- Use different secrets for development and production

```typescript
// app/lib/env.ts
import { z } from 'zod';

const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  API_KEY: z.string().min(10),
  JWT_SECRET: z.string().min(32),
  NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),
});

// Parse and validate environment variables
const env = envSchema.safeParse(process.env);

if (!env.success) {
  console.error('Invalid environment variables:', env.error.format());
  throw new Error('Invalid environment variables');
}

// Export validated environment variables
export const config = env.data;
```

## Deployment Best Practices

### Environment Configuration

- Use environment variables for configuration
- Implement environment-specific settings
- Set up proper development, staging, and production environments
- Use feature flags for controlled rollouts
- Document environment requirements

### Monitoring and Observability

- Implement proper logging and monitoring
- Use transaction tracing across serverless functions
- Monitor function performance and execution time
- Set up alerts for errors and performance issues
- Analyze usage patterns and optimize accordingly

### CI/CD Integration

- Automate testing and deployment
- Implement preview deployments for pull requests
- Use progressive deployment strategies
- Roll back automatically on failures
- Validate environment variables in CI/CD pipeline
