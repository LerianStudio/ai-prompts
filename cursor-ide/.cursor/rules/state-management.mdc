---
description: Best practices for managing application state, including Redux implementation, data flow patterns, and state organization
globs: src/**/*.{ts,tsx}
alwaysApply: false
---

# State Management Guidelines

## Overview

This project uses React Context for global state management with a provider-based architecture. The state management strategy emphasizes clean separation of concerns, predictable state updates, and efficient re-rendering patterns.

## Architecture Patterns

### Provider Structure
State management is organized through specialized context providers in [src/providers](mdc:src/providers):

- [organization-provider](mdc:src/providers/organization-provider) - Organization context and selection
- [permission-provider](mdc:src/providers/permission-provider) - User permissions and access control

### State Management Hierarchy
```typescript
// Application state hierarchy
<I18nProvider>
  <ThemeProvider>
    <OrganizationProvider>
      <PermissionProvider>
        <App />
      </PermissionProvider>
    </OrganizationProvider>
  </ThemeProvider>
</I18nProvider>
```

## Organization State Management

### Organization Provider Implementation
```typescript
// src/providers/organization-provider/index.tsx
interface OrganizationContextValue {
  currentOrganization: Organization | null;
  organizations: Organization[];
  isLoading: boolean;
  error: string | null;
  switchOrganization: (organizationId: string) => Promise<void>;
  refreshOrganizations: () => Promise<void>;
}

const OrganizationContext = createContext<OrganizationContextValue | undefined>(undefined);

export function OrganizationProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState<OrganizationState>({
    currentOrganization: null,
    organizations: [],
    isLoading: true,
    error: null,
  });

  const switchOrganization = useCallback(async (organizationId: string) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const organization = await organizationService.getById(organizationId);
      localStorage.setItem('selectedOrganizationId', organizationId);

      setState(prev => ({
        ...prev,
        currentOrganization: organization,
        isLoading: false,
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: error.message,
        isLoading: false,
      }));
    }
  }, []);

  const refreshOrganizations = useCallback(async () => {
    try {
      const organizations = await organizationService.getAll();
      setState(prev => ({ ...prev, organizations }));
    } catch (error) {
      setState(prev => ({ ...prev, error: error.message }));
    }
  }, []);

  const value = useMemo(() => ({
    ...state,
    switchOrganization,
    refreshOrganizations,
  }), [state, switchOrganization, refreshOrganizations]);

  return (
    <OrganizationContext.Provider value={value}>
      {children}
    </OrganizationContext.Provider>
  );
}

export function useOrganization() {
  const context = useContext(OrganizationContext);
  if (context === undefined) {
    throw new Error('useOrganization must be used within an OrganizationProvider');
  }
  return context;
}
```

### Organization State Usage
```typescript
// Using organization context in components
export function OrganizationSwitcher() {
  const {
    currentOrganization,
    organizations,
    switchOrganization,
    isLoading
  } = useOrganization();

  const handleSwitch = (organizationId: string) => {
    switchOrganization(organizationId);
  };

  if (isLoading) {
    return <LoadingSpinner />;
  }

  return (
    <Select onValueChange={handleSwitch} value={currentOrganization?.id}>
      <SelectTrigger>
        <SelectValue placeholder="Select organization" />
      </SelectTrigger>
      <SelectContent>
        {organizations.map((org) => (
          <SelectItem key={org.id} value={org.id}>
            {org.name}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
}
```

## Permission State Management

### Permission Provider Implementation
```typescript
// src/providers/permission-provider/index.tsx
interface Permission {
  resource: string;
  action: string;
  scope?: string;
}

interface PermissionContextValue {
  permissions: Permission[];
  isLoading: boolean;
  hasPermission: (resource: string, action: string, scope?: string) => boolean;
  refreshPermissions: () => Promise<void>;
}

export function PermissionProvider({ children }: { children: React.ReactNode }) {
  const [permissions, setPermissions] = useState<Permission[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const { currentOrganization } = useOrganization();

  const hasPermission = useCallback((
    resource: string,
    action: string,
    scope?: string
  ) => {
    return permissions.some(permission =>
      permission.resource === resource &&
      permission.action === action &&
      (!scope || permission.scope === scope)
    );
  }, [permissions]);

  const refreshPermissions = useCallback(async () => {
    if (!currentOrganization) {
      setPermissions([]);
      setIsLoading(false);
      return;
    }

    setIsLoading(true);
    try {
      const userPermissions = await permissionService.getPermissions(
        currentOrganization.id
      );
      setPermissions(userPermissions);
    } catch (error) {
      console.error('Failed to load permissions:', error);
      setPermissions([]);
    } finally {
      setIsLoading(false);
    }
  }, [currentOrganization]);

  useEffect(() => {
    refreshPermissions();
  }, [refreshPermissions]);

  const value = useMemo(() => ({
    permissions,
    isLoading,
    hasPermission,
    refreshPermissions,
  }), [permissions, isLoading, hasPermission, refreshPermissions]);

  return (
    <PermissionContext.Provider value={value}>
      {children}
    </PermissionContext.Provider>
  );
}
```

### Permission-Based Access Control
```typescript
// Permission-based component rendering
export function ActionButton({ resource, action, children, ...props }) {
  const { hasPermission } = usePermission();

  if (!hasPermission(resource, action)) {
    return null;
  }

  return <Button {...props}>{children}</Button>;
}

// Usage in components
export function AccountsPage() {
  return (
    <div>
      <PageHeader title="Accounts" />
      <ActionButton
        resource="accounts"
        action="create"
        onClick={handleCreateAccount}
      >
        Create Account
      </ActionButton>
      <AccountsList />
    </div>
  );
}
```

## Local State Management

### Component State Patterns
```typescript
// Simple local state
export function UserForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
  });

  const handleInputChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    <form>
      <Input
        value={formData.name}
        onChange={(e) => handleInputChange('name', e.target.value)}
      />
    </form>
  );
}

// Complex state with useReducer
interface TableState {
  data: any[];
  loading: boolean;
  error: string | null;
  selectedRows: string[];
  sortBy: string;
  sortDirection: 'asc' | 'desc';
  filters: Record<string, any>;
}

type TableAction =
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_DATA'; payload: any[] }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'TOGGLE_ROW_SELECTION'; payload: string }
  | { type: 'SET_SORT'; payload: { field: string; direction: 'asc' | 'desc' } }
  | { type: 'SET_FILTER'; payload: { field: string; value: any } };

function tableReducer(state: TableState, action: TableAction): TableState {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    case 'SET_DATA':
      return { ...state, data: action.payload, loading: false };
    case 'SET_ERROR':
      return { ...state, error: action.payload, loading: false };
    case 'TOGGLE_ROW_SELECTION':
      const rowId = action.payload;
      const isSelected = state.selectedRows.includes(rowId);
      return {
        ...state,
        selectedRows: isSelected
          ? state.selectedRows.filter(id => id !== rowId)
          : [...state.selectedRows, rowId],
      };
    case 'SET_SORT':
      return {
        ...state,
        sortBy: action.payload.field,
        sortDirection: action.payload.direction,
      };
    case 'SET_FILTER':
      return {
        ...state,
        filters: { ...state.filters, [action.payload.field]: action.payload.value },
      };
    default:
      return state;
  }
}

export function DataTable() {
  const [state, dispatch] = useReducer(tableReducer, {
    data: [],
    loading: false,
    error: null,
    selectedRows: [],
    sortBy: '',
    sortDirection: 'asc',
    filters: {},
  });

  // Table implementation using dispatch for state updates
}
```

## Data Fetching and Caching

### React Query Integration
```typescript
// Custom hooks with React Query
export function useOrganizations() {
  return useQuery({
    queryKey: ['organizations'],
    queryFn: () => organizationService.getAll(),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
  });
}

export function useAccounts(organizationId: string, ledgerId: string) {
  return useQuery({
    queryKey: ['accounts', organizationId, ledgerId],
    queryFn: () => accountService.getByLedger(organizationId, ledgerId),
    enabled: !!(organizationId && ledgerId),
  });
}

// Mutations with optimistic updates
export function useCreateAccount() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: accountService.create,
    onMutate: async (newAccount) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries(['accounts']);

      // Snapshot previous value
      const previousAccounts = queryClient.getQueryData(['accounts']);

      // Optimistically update
      queryClient.setQueryData(['accounts'], (old: any[]) => [
        ...old,
        { ...newAccount, id: `temp-${Date.now()}` },
      ]);

      return { previousAccounts };
    },
    onError: (err, newAccount, context) => {
      // Rollback on error
      queryClient.setQueryData(['accounts'], context?.previousAccounts);
    },
    onSettled: () => {
      // Refetch after success or error
      queryClient.invalidateQueries(['accounts']);
    },
  });
}
```

### SWR Alternative Pattern
```typescript
// Using SWR for data fetching
export function useAccounts(organizationId: string, ledgerId: string) {
  const { data, error, mutate } = useSWR(
    organizationId && ledgerId ? `/accounts/${organizationId}/${ledgerId}` : null,
    () => accountService.getByLedger(organizationId, ledgerId),
    {
      revalidateOnFocus: false,
      dedupingInterval: 60000,
    }
  );

  return {
    accounts: data || [],
    isLoading: !error && !data,
    error,
    mutate,
  };
}
```

## State Synchronization

### Cross-Component Communication
```typescript
// Event-based communication for loosely coupled components
class EventBus {
  private events: Map<string, Function[]> = new Map();

  subscribe(event: string, callback: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback);

    return () => {
      const callbacks = this.events.get(event);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    };
  }

  emit(event: string, data?: any) {
    const callbacks = this.events.get(event);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }
}

export const eventBus = new EventBus();

// Usage in components
export function AccountForm() {
  const handleSubmit = async (data) => {
    await accountService.create(data);
    eventBus.emit('account:created', data);
  };
}

export function AccountsList() {
  const [accounts, setAccounts] = useState([]);

  useEffect(() => {
    const unsubscribe = eventBus.subscribe('account:created', (newAccount) => {
      setAccounts(prev => [...prev, newAccount]);
    });

    return unsubscribe;
  }, []);
}
```

## State Persistence

### Local Storage Integration
```typescript
// Persistent state hook
export function usePersistentState<T>(
  key: string,
  defaultValue: T
): [T, (value: T) => void] {
  const [state, setState] = useState<T>(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch {
      return defaultValue;
    }
  });

  const setPersistentState = useCallback((value: T) => {
    setState(value);
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`Failed to persist state for key "${key}":`, error);
    }
  }, [key]);

  return [state, setPersistentState];
}

// Usage
export function UserPreferences() {
  const [theme, setTheme] = usePersistentState('theme', 'light');
  const [language, setLanguage] = usePersistentState('language', 'en');

  return (
    <div>
      <ThemeSelector value={theme} onChange={setTheme} />
      <LanguageSelector value={language} onChange={setLanguage} />
    </div>
  );
}
```

### Session Storage for Temporary State
```typescript
// Session-based state for temporary data
export function useSessionState<T>(
  key: string,
  defaultValue: T
): [T, (value: T) => void] {
  const [state, setState] = useState<T>(() => {
    try {
      const item = sessionStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch {
      return defaultValue;
    }
  });

  const setSessionState = useCallback((value: T) => {
    setState(value);
    try {
      sessionStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`Failed to save session state for key "${key}":`, error);
    }
  }, [key]);

  return [state, setSessionState];
}
```

## Performance Optimization

### Memoization Strategies
```typescript
// Memoizing expensive computations
export function ExpensiveComponent({ data, filters }) {
  const filteredData = useMemo(() => {
    return data.filter(item =>
      Object.entries(filters).every(([key, value]) =>
        item[key]?.toString().toLowerCase().includes(value.toLowerCase())
      )
    );
  }, [data, filters]);

  const sortedData = useMemo(() => {
    return [...filteredData].sort((a, b) => a.name.localeCompare(b.name));
  }, [filteredData]);

  return (
    <div>
      {sortedData.map(item => (
        <ItemComponent key={item.id} item={item} />
      ))}
    </div>
  );
}

// Memoizing callback functions
export function ParentComponent() {
  const [count, setCount] = useState(0);
  const [items, setItems] = useState([]);

  const handleItemClick = useCallback((itemId: string) => {
    setItems(prev => prev.map(item =>
      item.id === itemId
        ? { ...item, clicked: true }
        : item
    ));
  }, []);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      {items.map(item => (
        <MemoizedItemComponent
          key={item.id}
          item={item}
          onClick={handleItemClick}
        />
      ))}
    </div>
  );
}

const MemoizedItemComponent = React.memo(({ item, onClick }) => {
  return (
    <div onClick={() => onClick(item.id)}>
      {item.name}
    </div>
  );
});
```

## State Management Best Practices

### Context Design Principles
- **Single Responsibility**: Each context should manage one specific domain
- **Granular Updates**: Minimize re-renders by splitting contexts appropriately
- **Error Boundaries**: Wrap providers with error boundaries
- **Type Safety**: Use TypeScript for all context definitions

### Performance Guidelines
- Use `useMemo` and `useCallback` to prevent unnecessary re-renders
- Split large contexts into smaller, focused ones
- Implement proper dependency arrays in hooks
- Consider using React.memo for expensive child components

### Testing State Management
```typescript
// Testing context providers
import { renderHook } from '@testing-library/react';
import { OrganizationProvider, useOrganization } from './organization-provider';

describe('OrganizationProvider', () => {
  const wrapper = ({ children }) => (
    <OrganizationProvider>{children}</OrganizationProvider>
  );

  it('should provide initial state', () => {
    const { result } = renderHook(() => useOrganization(), { wrapper });

    expect(result.current.currentOrganization).toBeNull();
    expect(result.current.organizations).toEqual([]);
    expect(result.current.isLoading).toBe(true);
  });

  it('should switch organization', async () => {
    const { result } = renderHook(() => useOrganization(), { wrapper });

    await act(async () => {
      await result.current.switchOrganization('org-123');
    });

    expect(result.current.currentOrganization?.id).toBe('org-123');
  });
});
```

### Error Handling in State
```typescript
// Error boundary for state providers
export class StateErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    logger.error('State management error:', {
      error: error.message,
      stack: error.stack,
      errorInfo,
    });
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback onRetry={() => this.setState({ hasError: false })} />;
    }

    return this.props.children;
  }
}
```
