---
description: Guidelines for writing clear and consistent git commit messages following conventional commits specification
globs: src/**/*.{ts,tsx}
alwaysApply: false
---
## ğŸš¨ ABSOLUTE MANDATORY COMMIT PROCESS

**âš ï¸ ZERO TOLERANCE POLICY - VIOLATION = IMMEDIATE REJECTION**

ALL commits **MUST** use a temporary file. Direct commits with -m flag are **ABSOLUTELY FORBIDDEN**.

### ğŸ”’ MANDATORY WORKFLOW - NO EXCEPTIONS

**STEP 1: CREATE EMPTY TEMPORARY FILE - ALWAYS REQUIRED**
```bash
# MANDATORY: Create empty temporary file first
git_msg=$(mktemp)
echo "COMMIT_MESSAGE_PLACEHOLDER" > "$git_msg"
```

**STEP 2: EDIT THE TEMPORARY FILE WITH YOUR MESSAGE**
```bash
# MANDATORY: Use your preferred editor to write the commit message
nano "$git_msg"
# OR
vim "$git_msg"
# OR
code "$git_msg"
```

**STEP 3: VERIFY FILE FORMAT**
```bash
# MANDATORY: Check the file exists and has content
cat "$git_msg"
```

**STEP 4: COMMIT USING THE FILE**
```bash
# MANDATORY: Commit using the temporary file
git commit -F "$git_msg"
```

**STEP 5: CLEANUP**
```bash
# MANDATORY: Remove temporary file
rm "$git_msg"
```

### ğŸš« ABSOLUTE VIOLATIONS - NEVER ALLOWED

âŒ **FORBIDDEN**: `git commit -m "message"`
âŒ **FORBIDDEN**: `git commit -m "line1" -m "line2"`
âŒ **FORBIDDEN**: Direct inline multiline messages
âŒ **FORBIDDEN**: Committing without creating a temporary file first
âŒ **FORBIDDEN**: Using echo with pipes directly to git commit
âŒ **FORBIDDEN**: Any commit method that bypasses file creation

### âœ… MANDATORY ALTERNATIVE METHODS

**Method 1: Using cat with EOF (PREFERRED)**
```bash
# MANDATORY: Create empty file first, then populate
git_msg=$(mktemp)
cat > "$git_msg" << 'EOF'
feat(scope): short description

- Bullet point 1
- Bullet point 2
- Bullet point 3

BREAKING CHANGE: description of breaking changes
EOF

git commit -F "$git_msg"
rm "$git_msg"
```

**Method 2: Using printf (ACCEPTABLE)**
```bash
# MANDATORY: Create empty file first, then populate
git_msg=$(mktemp)
printf "feat(scope): short description\n\n- Bullet point 1\n- Bullet point 2\n\nBREAKING CHANGE: description" > "$git_msg"
git commit -F "$git_msg"
rm "$git_msg"
```

**Method 3: Using editor (ACCEPTABLE)**
```bash
# MANDATORY: Create empty file first, then edit
git_msg=$(mktemp)
touch "$git_msg"  # Ensure file exists
$EDITOR "$git_msg"
git commit -F "$git_msg"
rm "$git_msg"
```

## ğŸš€ Conventional Commits Guidelines - ENFORCED

This project uses **Conventional Commits** to automate changelogs and versioning via `semantic-release`.

Only `feat`, `fix`, or `BREAKING CHANGE` will trigger version bumps. All types are parsed for changelogs.

### âœ… MANDATORY Format

<type>(<optional-scope>): <short description>

[optional body]

[optional footer(s)]

### ğŸ¯ MANDATORY Examples

**ALL EXAMPLES MUST USE TEMPORARY FILES:**

```bash
# MANDATORY: Feature example
git_msg=$(mktemp)
cat > "$git_msg" << 'EOF'
feat(auth): enable biometric login support
EOF
git commit -F "$git_msg"
rm "$git_msg"

# MANDATORY: Fix example
git_msg=$(mktemp)
cat > "$git_msg" << 'EOF'
fix(api): resolve timeout on /users
EOF
git commit -F "$git_msg"
rm "$git_msg"

# MANDATORY: Multi-line example
git_msg=$(mktemp)
cat > "$git_msg" << 'EOF'
feat(applications): implement application management API

- Add CRUD operations for applications management
- Create application-related API endpoints
- Implement React Query hooks for application data fetching
- Extract security alert to a separate component
- Add application options environment variable
- Update forms to use real API data instead of mocks
EOF
git commit -F "$git_msg"
rm "$git_msg"
```

### ğŸ§  Version Bumps - REFERENCE

| Type              | Triggers Version?  | Notes                                 |
|-------------------|--------------------|----------------------------------------|
| `feat`            | **Minor** bump     | Adds new feature (v1.2.0 â†’ v1.3.0)     |
| `fix`             | **Patch** bump     | Bug fix (v1.2.3 â†’ v1.2.4)              |
| `BREAKING CHANGE` | **Major** bump     | Any type with breaking footer          |
| Others            | No bump            | Still included in changelog            |

### ğŸ”¥ MANDATORY Breaking Change Example

```bash
# MANDATORY: Breaking change must use temporary file
git_msg=$(mktemp)
cat > "$git_msg" << 'EOF'
feat(auth): switch to OAuth2

BREAKING CHANGE: legacy auth removed, update login flow
EOF
git commit -F "$git_msg"
rm "$git_msg"
```

### ğŸ›‘ Common Mistakes - FORBIDDEN

- `fix:` â† âŒ too vague (needs a subject)
- `feature:` â† âŒ invalid type
- `Update login screen` â† âŒ no type prefix
- **ANY use of `git commit -m`** â† âŒ **ABSOLUTELY FORBIDDEN**

### ğŸ§ª Test Your Commits

```bash
npx commitlint --from=HEAD~5 --to=HEAD
```

### ğŸ“š Reference

- https://www.conventionalcommits.org/en/v1.0.0/
- https://semantic-release.gitbook.io

## ğŸ”§ AUTOMATION SCRIPTS - RECOMMENDED

### Bash Function for Safe Commits
```bash
# Add to your ~/.bashrc or ~/.zshrc
safe_commit() {
    local git_msg=$(mktemp)
    echo "# Write your commit message below (delete this line)" > "$git_msg"
    echo "" >> "$git_msg"
    echo "# Example: feat(scope): description" >> "$git_msg"
    echo "# " >> "$git_msg"
    echo "# - Bullet point 1" >> "$git_msg"
    echo "# - Bullet point 2" >> "$git_msg"
    
    $EDITOR "$git_msg"
    
    # Remove comment lines
    sed -i '/^#/d' "$git_msg"
    
    # Check if file has content after removing comments
    if [[ -s "$git_msg" ]]; then
        echo "Commit message:"
        cat "$git_msg"
        echo ""
        read -p "Proceed with commit? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            git commit -F "$git_msg"
        else
            echo "Commit cancelled"
        fi
    else
        echo "Empty commit message, cancelled"
    fi
    
    rm "$git_msg"
}
```

### Git Alias for Safe Commits
```bash
# Add to your ~/.gitconfig
[alias]
    cm = "!f() { \
        local git_msg=$(mktemp); \
        printf '%s\n\n%s\n' \"$1\" \"${@:2}\" > \"$git_msg\"; \
        git commit -F \"$git_msg\"; \
        rm \"$git_msg\"; \
    }; f"
```

## ğŸš¨ VIOLATION CONSEQUENCES

**ANY VIOLATION OF THESE MANDATORY COMMIT RULES WILL RESULT IN:**

### Immediate Actions:
- âŒ **COMMIT REJECTION** - Commit will be blocked/reverted
- âŒ **PULL REQUEST FAILURE** - Automated checks will fail
- âŒ **CI/CD PIPELINE FAILURE** - Builds will be blocked
- âŒ **CODE REVIEW REJECTION** - Manual review will fail

### Corrective Actions Required:
- ğŸ”„ **MANDATORY COMMIT REWRITE** - Must redo commit properly
- ğŸ”„ **FORCE PUSH REQUIRED** - History must be corrected
- ğŸ”„ **WORKFLOW EDUCATION** - Team training required
- ğŸ”„ **PROCESS VERIFICATION** - Must demonstrate proper workflow

### Escalation:
- ğŸ“ˆ **REPEATED VIOLATIONS** - Management escalation
- ğŸ“ˆ **TEAM IMPACT** - Process improvement required
- ğŸ“ˆ **PROJECT DELAYS** - Additional oversight implemented

## ğŸ” COMMIT VERIFICATION CHECKLIST

Before every commit, verify:

- [ ] âœ… Created temporary file using `mktemp`
- [ ] âœ… File exists and is writable
- [ ] âœ… Message follows conventional commit format
- [ ] âœ… Used `git commit -F "$file"` command
- [ ] âœ… Cleaned up temporary file with `rm`
- [ ] âœ… Never used `git commit -m` flag
- [ ] âœ… Message has proper format and content
- [ ] âœ… Breaking changes are documented if applicable

**NO EXCEPTIONS. NO SHORTCUTS. NO COMPROMISES.**
